% File src/library/grid/vignettes/plotexample.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}
%\VignetteIndexEntry{Writing grid Code}
%\VignettePackage{grid}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\grid}{\pkg{grid}}
\newcommand{\grob}{\code{grob}}
\newcommand{\gTree}{\code{gTree}}
\newcommand{\R}{{\sffamily R}}
\newcommand{\I}[1]{#1}
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\newcommand{\aside}[1]{\begin{list}{}
                                   {\setlength{\leftmargin}{1in}
                                    \setlength{\rightmargin}{1in}
                                    \setlength{\itemindent}{0in}}
                       \item \textsc{Aside:} \emph{#1}
                       \end{list}}

\title{Writing \grid{} Code}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(stats) # for runif()
library(grid)
ps.options(pointsize=12)
options(width=60)
@

The \grid{} system incorporates a degree of complexity to support
features such as editing graphical objects, ``packing'' graphical
objects, and similar advanced operations. Consequently, many of the
predefined \grid{} graphics functions are relatively
intricate\footnote{There are exceptions; some functions, like
  \code{grid.show.viewport}, serve purely illustrative purposes and
  remain simple and procedural.}.

A design goal of \grid{} is to allow users to produce simple graphics
with straightforward code, without forcing the adoption of complex
concepts or elaborate implementations unless genuinely required.
Similarly, the system aims to let users prototype even sophisticated
graphics very simply and later refine the implementation into a more
polished form if necessary.

Given that the predefined graphics functions are fully‑developed and
often complex, there is a shortage of examples demonstrating simple,
prototypical code. Furthermore, because \grid{} permits multiple
approaches to achieve the same graphical output, examples illustrating
the various stages—from simple to complex—through which a piece of
\grid{} code can evolve are valuable.

This document describes the construction of a scatterplot object,
similar to the one shown below, progressing from the simplest,
prototype implementation to the most elaborate and sophisticated. It
shows that if one only requires straightforward graphical output, it
can be produced quite simply and quickly. It also illustrates how to
write functions that allow others to use your graphics. Finally, it
demonstrates how to make your graphics fully interactive (or at least
as interactive as \grid{} permits).

This document should be read \emph{after} the \grid{} Users' Guide.
We assume the reader possesses an understanding of viewports, layouts,
and units. For the later sections, familiarity with \R{}'s \code{S3}
object system will also be helpful.

\section*{Procedural \grid{}}

The most direct way to generate graphical output in \grid{} parallels
the approach used in standard \R{} graphics: issue a sequence of
graphics commands, each adding more ink to the plot. The purpose of
these commands is solely to produce output; we are not concerned with
any values returned by the plotting functions. We will term this
\emph{procedural graphics}.

To draw a simple scatterplot, we can execute a series of commands that
draw the various components of the plot.

Here are some random data to plot.

<<>>=
x <- runif(10)
y <- runif(10)
@
\noindent
The first step in creating the plot involves defining a ``data''
region. This region provides sensible axis scales for plotting the
data, margins around the outside to accommodate the axes, and space
for a title at the top.

<<datavp>>=
data.vp <- viewport(x = unit(5, "lines"),
                    y = unit(4, "lines"),
                    width = unit(1, "npc") - unit(7, "lines"),
                    height = unit(1, "npc") - unit(7, "lines"),
                    just = c("left", "bottom"),
                    xscale = range(x) + c(-0.05, 0.05)*diff(range(x)),
                    yscale = range(y) + c(-0.05, 0.05)*diff(range(y)))
@
\noindent
Now we create the data region and draw the components of the plot
relative to it: points, axes, labels, and a title.

<<procplot>>=
pushViewport(data.vp)
grid.points(x, y)
grid.rect()
grid.xaxis()
grid.yaxis()
grid.text("x axis", y = unit(-3, "lines"),
          gp = gpar(fontsize = 14))
grid.text("y axis", x = unit(-4, "lines"),
          gp = gpar(fontsize = 14), rot = 90)
grid.text("A Simple Plot",
          y = unit(1, "npc") + unit(1.5, "lines"),
          gp = gpar(fontsize = 16))
popViewport()
<<fig=TRUE, echo=FALSE, results=hide>>=
<<procplot>>
@
\section*{Facilitating Annotation}

Issuing a series of commands to produce a plot, as in the previous
section, affords the user considerable flexibility. It is always
possible to recreate viewports in order to add further annotations.
For example, the following code recreates the data region to place the
current date in the bottom‑right corner.

<<ann1>>=
pushViewport(data.vp)
grid.text(date(), x = unit(1, "npc"), y = 0,
          just = c("right", "bottom"), gp = gpar(col="grey"))
popViewport()
<<fig=TRUE, echo=FALSE, results=hide>>=
<<procplot>>
<<ann1>>
@

When more complex arrangements of viewports are involved, a
bewildering array of viewports may be created, making it difficult for
other users to revisit a particular region of a plot. A \code{lattice}
plot is a good example. In such cases, it is more cooperative to use
\code{upViewport()} rather than \code{popViewport()} and leave the
viewports created during drawing in place. Other users can then employ
\code{vpPath}s to navigate to the desired region. For example, here is
a slight modification of the original sequence of commands, where the
original data viewport is given a name and \code{upViewport()} is used
at the end.

<<results=hide>>=
data.vp <- viewport(name = "dataregion",
                    x = unit(5, "lines"),
                    y = unit(4, "lines"),
                    width = unit(1, "npc") - unit(7, "lines"),
                    height = unit(1, "npc") - unit(7, "lines"),
                    just = c("left", "bottom"),
                    xscale = range(x) + c(-0.05, 0.05)*diff(range(x)),
                    yscale = range(y) + c(-0.05, 0.05)*diff(range(y)))
pushViewport(data.vp)
grid.points(x, y)
grid.rect()
grid.xaxis()
grid.yaxis()
grid.text("x axis", y = unit(-3, "lines"),
          gp = gpar(fontsize = 14))
grid.text("y axis", x = unit(-4, "lines"),
          gp = gpar(fontsize = 14), rot = 90)
grid.text("A Simple Plot",
          y = unit(1, "npc") + unit(1.5, "lines"),
          gp = gpar(fontsize = 16))
upViewport()
@

The date can now be added using \code{downViewport()} to reach the
data region.

<<results=hide>>=
downViewport("dataregion")
grid.text(date(), x = unit(1, "npc"), y  =  0,
          just = c("right", "bottom"), gp = gpar(col = "grey"))
upViewport()
@
\section*{Writing a \grid{} Function}

Here is the scatterplot code encapsulated within a simple function.

<<funcplot>>=
splot <- function(x = runif(10), y = runif(10), title = "A Simple Plot") {
    data.vp <- viewport(name = "dataregion",
                        x = unit(5, "lines"),
                        y = unit(4, "lines"),
                        width = unit(1, "npc") - unit(7, "lines"),
                        height = unit(1, "npc") - unit(7, "lines"),
                        just = c("left", "bottom"),
                        xscale = range(x) + c(-.05, .05)*diff(range(x)),
                        yscale = range(y) + c(-.05, .05)*diff(range(y)))
    pushViewport(data.vp)
    grid.points(x, y)
    grid.rect()
    grid.xaxis()
    grid.yaxis()
    grid.text("y axis", x = unit(-4, "lines"),
              gp = gpar(fontsize = 14), rot = 90)
    grid.text(title, y = unit(1, "npc") + unit(1.5, "lines"),
              gp = gpar(fontsize = 16))
    upViewport()
}
@
Creating a function offers several advantages:
\begin{enumerate}
\item We gain the standard benefits of a function: the plot code
  becomes easier to reuse and maintain.
\item We can slightly generalize the plot. Here we allow different
  data and a custom title. Additional arguments could be added to
  control margins, axis scales, etc.
\item The plot can be embedded within other graphical output.
\end{enumerate}
The following example uses the \code{splot()} function to create a
modified scatterplot embedded within other \grid{} output.

<<embed, fig=TRUE, results=hide>>=
grid.rect(gp = gpar(fill = "grey"))
message <-
    paste("I could draw all sorts",
          "of stuff over here",
          "then create a viewport",
          "over there and stick",
          "a scatterplot in it.", sep = "\n")
grid.text(message, x = 0.25)
grid.lines(x = unit.c(unit(0.25, "npc") + 0.5*stringWidth(message) +
           unit(2, "mm"),
           unit(0.5, "npc") - unit(2, "mm")),
           y = 0.5,
           arrow = arrow(angle = 15, type = "closed"),
           gp = gpar(lwd = 3, fill = "black"))
pushViewport(viewport(x = 0.5, height = 0.5, width = 0.45, just = "left",
                      gp = gpar(cex = 0.5)))
grid.rect(gp = gpar(fill = "white"))
splot(1:10, 1:10, title = "An Embedded Plot")
upViewport()
@

Annotating the scatterplot remains straightforward as long as we have
sufficient information about the viewports. In this case, a non‑strict
\code{downViewport()} still works (though note that
\code{upViewport({\bf 0})} is required to return fully to the top
level).

<<ann2, echo = FALSE, eval=FALSE>>=
downViewport("dataregion")
grid.text(date(), x = unit(1, "npc"), y  =  0,
          just = c("right", "bottom"), gp = gpar(col = "grey"))
upViewport(0)
<<echo=FALSE, results=hide>>=
<<embed>>
<<ann2>>
@
\section*{Creating \grid{} Graphical Objects}

A \grid{} function like the one in the previous section yields output
that is flexible, can be annotated arbitrarily, and can be embedded
within other output. Such a function will satisfy most needs.

However, certain actions are difficult or impossible to perform with
such a function. The output produced by the function cannot be
addressed as a coherent whole. For instance, one cannot change the
\code{x} and \code{y} data used in the plot and have the points and
axes update automatically. There is no scatterplot object to save; the
individual components exist but are not bound together. When these
kinds of requirements become important, it becomes necessary to create
a \grid{} graphical object (a \grob{}) to represent the plot.

The first step is to write a constructor function that creates a
\grob{}. In most cases this involves creating a special type of
\grob{} called a \gTree{}, which is a \grob{} that can contain other
\grob{}s as children. The following is an example constructor for an
\code{splot} \grob{}. Some parts of the construction are placed in
separate helper functions for reasons that will become apparent later.

<<>>=
splot.data.vp <- function(x, y) {
  viewport(name = "dataregion",
           x = unit(5, "lines"),
           y = unit(4, "lines"),
           width = unit(1, "npc") - unit(7, "lines"),
           height = unit(1, "npc") - unit(7, "lines"),
           just = c("left", "bottom"),
           xscale = range(x) + c(-.05, .05)*diff(range(x)),
           yscale = range(y) + c(-.05, .05)*diff(range(y)))
}

splot.title <- function(title) {
      textGrob(title, name = "title",
               y = unit(1, "npc") + unit(1.5, "lines"),
               gp = gpar(fontsize = 16), vp = "dataregion")
}

splot <- function(x, y, title, name=NULL, draw=TRUE, gp=gpar(), vp=NULL) {
    spg <- gTree(x = x, y = y, title = title, name = name,
                 childrenvp  =  splot.data.vp(x, y),
                 children = gList(rectGrob(name = "border",
                                           vp = "dataregion"),
                 xaxisGrob(name = "xaxis", vp = "dataregion"),
                 yaxisGrob(name = "yaxis", vp = "dataregion"),
                 pointsGrob(x, y, name = "points", vp = "dataregion"),
                 textGrob("x axis", y = unit(-3, "lines"), name = "xlab",
                          gp = gpar(fontsize = 14), vp = "dataregion"),
                 textGrob("y axis", x = unit(-4, "lines"), name = "ylab",
                          gp = gpar(fontsize = 14), rot = 90,
                          vp = "dataregion"),
                 splot.title(title)),
                 gp = gp, vp = vp,
                 cl = "splot")
    if (draw) grid.draw(spg)
    spg
}
@

Four important arguments have been added compared to the original
\code{splot()} function:
\begin{enumerate}
\item The \code{name} argument allows a string identifier to be
  associated with the scatterplot object. This is essential for
  specifying the scatterplot when editing it after drawing or when it
  forms part of a larger \grob{} (see later examples).

\item The \code{draw} argument permits the function to be used
  procedurally as before:

<<splotgrob, eval=FALSE, echo=FALSE>>=
sg <- splot(1:10, 1:10, "Same as Before", name = "splot", draw = FALSE)
<<>>=
splot(1:10, 1:10, "Same as Before", name = "splot")
downViewport("dataregion")
grid.text(date(), x = unit(1, "npc"), y = 0,
          just = c("right", "bottom"), gp = gpar(col = "grey"))
upViewport(0)
@
\item The \code{gp} argument allows the user to supply \code{gpar()}
  settings that apply to the scatterplot as a whole.

\item The \code{vp} argument allows the user to specify a viewport in
  which the \code{splot} \grob{} will be drawn. This is particularly
  useful for supplying a \code{vpPath} when the \code{splot} is used
  as a component of another \grob{} (see the scatterplot matrix example
  below).
\end{enumerate}

Key aspects of the \gTree{} definition are:
\begin{enumerate}
\item The \code{children} argument provides a list of \grob{}s that
  constitute the scatterplot. When the scatterplot is drawn, all
  children are drawn. Note that instead of the procedural
  \code{grid.*()} functions we now use \code{*Grob()} functions, which
  produce \grob{} descriptions without performing any drawing. Each
  child is given a name; this will enable access to individual
  components of the scatterplot (see later examples).

\item The \code{childrenvp} argument provides a viewport (or
  \code{vpStack}, \code{vpList}, or \code{vpTree}) that will be pushed
  before the children are drawn. The difference between this argument
  and the \code{vp} argument common to all \grob{}s is that the
  \code{vp} is pushed before drawing the children and then popped
  afterward, whereas the \code{childrenvp} is pushed \emph{and then} a
  call to \code{upViewport()} is made before the children are drawn.
  This allows children to simply specify the viewport they should
  occupy via a \code{vpPath} in their own \code{vp} argument. In this
  way, viewports remain available for further annotation, as we have
  already seen in procedural code.

\item The \code{gp} and \code{vp} arguments are automatically handled
  by the \gTree{} drawing methods, so \code{gpar()} settings are
  enforced and the viewport is pushed when the \code{splot} is drawn.

\item The \code{cl} argument indicates that the created \grob{} is a
  special type called \code{splot}. This will allow us to write
  methods specifically for our scatterplot (see later examples).
\end{enumerate}

Now that we have a \grob{}, more interesting operations become
possible. First, the \code{splot} \grob{} serves as a container for
the \grob{}s that make up the scatterplot. Modifying the \code{splot}
\grob{} affects all its children.

<<results=hide>>=
splot(1:10, 1:10, "Same as Before", name = "splot")
grid.edit("splot", gp = gpar(cex=0.5))
<<fig=TRUE, echo=FALSE, results=hide>>=
<<splotgrob>>
sg <- editGrob(sg, gp = gpar(cex = 0.5))
grid.draw(sg)
@

We can also access individual elements of the \code{splot} \grob{} to
edit them separately.

<<results=hide>>=
splot(1:10, 1:10, "Same as Before", name = "splot")
grid.edit(gPath("splot", "points"), gp = gpar(col = 1:10))
<<fig=TRUE, echo=FALSE, results=hide>>=
<<splotgrob>>
sg <- editGrob(sg, gPath = "points", gp = gpar(col = 1:10))
grid.draw(sg)
@

With a little more effort we can make the scatterplot more dynamic.
The following defines an \code{editDetails()} method for the
\code{splot} \grob{}. This method is called whenever a scatterplot is
edited and updates the components of the scatterplot accordingly.

<<>>=
editDetails.splot <- function(x, specs) {
    if (any(c("x", "y") %in% names(specs))) {
        if (is.null(specs$x)) xx <- x$x else xx <- specs$x
        if (is.null(specs$y)) yy <- x$y else yy <- specs$y
        x$childrenvp <- splot.data.vp(xx, yy)
        x <- addGrob(x, pointsGrob(xx, yy, name = "points",
                                   vp = "dataregion"))
    }
  x
}
splot(1:10, 1:10, "Same as Before", name = "splot")
grid.edit("splot", x = 1:100, y = (1:100)^2)
<<fig=TRUE, echo=FALSE, results=hide>>=
<<splotgrob>>
sg <- editGrob(sg, x = 1:100, y = (1:100)^2)
grid.draw(sg)
@

The \code{splot} \grob{} can also be used in the construction of other
\grob{}s. Here is a simple scatterplot matrix \grob{}\footnote{{\bf
    Warning:} As the number of \grob{}s in a \gTree{} grows, the
  construction of the \gTree{} can become slow. If this occurs, a
  viable solution is to use a \grid{} function rather than a \gTree{}
  and wait for future implementations to improve performance.}.

<<fig=TRUE>>=
cellname <- function(i, j) paste("cell", i, j, sep = "")

splom.vpTree <- function(n) {
    vplist <- vector("list", n^2)
    for (i in 1:n)
        for (j in 1:n)
            vplist[[(i - 1)*n + j]] <-
              viewport(layout.pos.row = i, layout.pos.col = j,
                       name = cellname(i, j))
    vpTree(viewport(layout = grid.layout(n, n), name = "cellgrid"),
    do.call("vpList", vplist))
}

cellpath <- function(i, j) vpPath("cellgrid", cellname(i, j))

splom <- function(df, name = NULL, draw = TRUE) {
    n <- dim(df)[2]
    glist <- vector("list", n*n)
    for (i in 1:n)
        for (j in 1:n) {
            glist[[(i - 1)*n + j]] <-if (i == j)
                textGrob(paste("diag", i, sep = ""),
                         gp = gpar(col = "grey"), vp = cellpath(i, j))
            else if (j > i)
                textGrob(cellname(i, j),
                         name = cellname(i, j),
                         gp = gpar(col = "grey"), vp = cellpath(i, j))
            else
                splot(df[,j], df[,i], "",
                      name = paste("plot", i, j, sep = ""),
                      vp = cellpath(i, j),
                      gp = gpar(cex = 0.5), draw = FALSE)
        }
    smg <- gTree(name = name, childrenvp = splom.vpTree(n),
                 children = do.call("gList", glist))
    if (draw) grid.draw(smg)
    smg
}

df <- data.frame(x = rnorm(10), y = rnorm(10), z = rnorm(10))
splom(df)
@

This \grob{} can be edited in the usual manner:

<<>>=
splom(df)
grid.edit("plot21::xlab", label = "", redraw = FALSE)
grid.edit("plot32::ylab", label = "", redraw = FALSE)
grid.edit("plot21::xaxis", label = FALSE, redraw = FALSE)
grid.edit("plot32::yaxis", label = FALSE)
<<splomgrob, eval=FALSE, echo=FALSE>>=
smg <- splom(df, draw = FALSE)
<<fig=TRUE, echo=FALSE, results=hide>>=
<<splomgrob>>
smg <- editGrob(smg, gPath = "plot21::xaxis", label = FALSE)
smg <- editGrob(smg, gPath = "plot21::xlab", label = "")
smg <- editGrob(smg, gPath = "plot32::yaxis", label = FALSE)
smg <- editGrob(smg, gPath = "plot32::ylab", label = "")
grid.draw(smg)
@

Of greater interest, because this is a \grob{}, is the
\emph{programmatic} interface. With a \grob{} (as opposed to a
function) it is possible to modify the description of what is being
drawn via an API (rather than editing the original code). In the
following, we remove one of the ``spare'' cell labels and replace it
with the current date.

<<>>=
splom(df, name = "splom")
grid.remove("cell12")
grid.add("splom", textGrob(date(), name = "date",
                           gp = gpar(fontface = "italic"),
                           vp = "cellgrid::cell12"))
<<fig=TRUE, echo=FALSE, results=hide>>=
<<splomgrob>>
smg <- removeGrob(smg, "cell12")
smg <- addGrob(smg, textGrob(date(), name = "date",
                             gp = gpar(fontface = "italic"),
                             vp = "cellgrid::cell12"))
grid.draw(smg)
@

With the date added as a component of the scatterplot matrix, it is
saved as part of the matrix. The next sequence saves the scatterplot
matrix, reloads it, extracts the bottom‑left plot and the date, and
draws just those two objects together.

<<>>=
splom(df, name = "splom")
grid.remove("cell12")
grid.add("splom", textGrob(date(), name = "date",
                           gp = gpar(fontface = "italic"),
                           vp = "cellgrid::cell12"))
smg <- grid.get("splom")
save(smg, file = "splom.RData")
load("splom.RData")
plot <- getGrob(smg, "plot31")
date <- getGrob(smg, "date")
plot <- editGrob(plot, vp = NULL, gp = gpar(cex = 1))
date <- editGrob(date, y = unit(1, "npc") - unit(1, "lines"), vp = NULL)
grid.newpage()
grid.draw(plot)
grid.draw(date)

<<fig=TRUE, echo=FALSE, results=hide>>=
<<splomgrob>>
smg <- removeGrob(smg, "cell12")
smg <- addGrob(smg, textGrob(date(), name = "date",
                             gp = gpar(fontface = "italic"),
                             vp = "cellgrid::cell12"))
save(smg, file = "splom.RData")
load("splom.RData")
plot <- getGrob(smg, "plot31")
date <- getGrob(smg, "date")
plot <- editGrob(plot, vp = NULL, gp = gpar(cex = 1))
date <- editGrob(date, y = unit(1, "npc") - unit(1, "lines"), vp = NULL)
grid.draw(plot)
grid.draw(date)
@

All of this may appear somewhat tangential to interactive use, but it
provides a foundation for creating an editable plot interface, as
exemplified by \I{M.~Kondrin}'s \pkg{Rgrace} package (available on CRAN
2005–7).

\end{document}