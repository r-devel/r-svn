% File src/library/grid/vignettes/grobs.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

\usepackage{Rd}

% \VignetteIndexEntry{Working with grid grobs}
% \VignettePackage{grid}

\newcommand{\grid}{\pkg{grid}}
\newcommand{\grob}{\code{grob}}
\newcommand{\gTree}{\code{gTree}}
\newcommand{\gPath}{\code{gPath}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\newcommand{\I}[1]{#1}

\title{Modifying \grid{} \code{grob}s}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

A distinction exists between \grob{}s that are merely stored in
user‑level \R{} objects and \grob{}s that represent drawn output
(i.e., \grob{}s recorded on the \grid{} display list). A naming
convention is followed: functions of the form \code{grid.*()} are
primarily employed for their side effect of producing or modifying
output (they create or affect \grob{}s on the display list). Functions
of the form \code{*Grob()} are used for their return value; they
create or modify a \grob{} description without necessarily drawing it.
For example, the following code creates a \grob{} and then modifies it,
but performs no drawing; this is purely manipulation of a graphical
object description.

<<>>=
gl <- linesGrob()
gl <- editGrob(gl, gp = gpar(col = "green"))
@

The next example produces actual output. A \grob{} is returned, but
that \grob{} is only a description of the drawn output and has no
direct link to it. The \grob{} representing the drawn output can be
accessed using its \code{name}. To access a \grob{} that represents
drawn output (i.e., a \grob{} on the display list), one must specify a
\gPath{}. The \gPath{} should be created with the \code{gPath()}
function for script writing, but in interactive use it is permissible
to specify the \gPath{} directly as a string. The code below
demonstrates both approaches.

<<results=hide>>=
grid.newpage()
grid.lines(name = "lines")
grid.edit(gPath("lines"), gp = gpar(col = "pink"))
grid.edit("lines", gp = gpar(col = "red"))
@

Complex graphical objects are represented by the \gTree{} class. A
\gTree{} is a \grob{} that may contain other \grob{}s as children. The
\code{xaxis} and \code{yaxis} \grob{}s provided by \grid{} are
examples of \gTree{}s; the children of an axis include a lines \grob{}
for the tick marks and a text \grob{} for the tick‑mark labels. The
function \code{childNames()} lists the names of a \gTree{}'s children.
When working with such hierarchical objects, more complex \gPath{}s
can be used to access descendants of a \gTree{}. In the following
example, an x‑axis is drawn, then the \I{xaxis} itself is edited to
modify the tick‑mark positions, and finally the \I{xaxis}'s text child
is edited to adjust the label placement.

<<results=hide>>=
grid.newpage()
pushViewport(viewport(w = .5, h = .5))
grid.rect(gp = gpar(col = "grey"))
grid.xaxis(name = "myxaxis")
grid.edit("myxaxis", at = 1:4/5)
grid.edit(gPath("myxaxis", "labels"), y = unit(-1, "lines"))
@

This next example extends the idea further by editing a child of a
child of a \gTree{}. It also illustrates the use of the \gTree{}
function to construct a simple \gTree{} instance (this merely creates
an object of class \gTree{}; it is also possible to extend the
\gTree{} class to provide specialized drawing and other behaviors, a
topic addressed later). Finally, the example demonstrates how \gPath{}s
of depth greater than one can be supplied directly as a string.

<<results=hide>>=
grid.newpage()
pushViewport(viewport(w = .5, h = .5))
myplot <-
    gTree(name = "myplot",
          children = gList(rectGrob(name = "box", gp = gpar(col = "grey")),
                           xaxisGrob(name = "xaxis")))
grid.draw(myplot)
grid.edit("myplot::xaxis", at = 1:10/11)
grid.edit("myplot::xaxis::labels", label = round(1:10/11, 2))
grid.edit("myplot::xaxis::labels", y = unit(-1, "lines"))
@

\code{"grobwidth"} units require a \grob{} to determine the width.
There are two ways to specify this \grob{}. The following example
shows the most direct method of supplying a \grob{} object. Note that
subsequent modifications to \code{gt} will have no effect on the width
of the drawn rectangle.

<<results=hide>>=
grid.newpage()
gt <- grid.text("Hi there")
grid.rect(width = unit(1, "grobwidth", gt))
@

To allow a \code{"grobwidth"} unit to track changes in the underlying
\grob{}, one may specify a \gPath{} rather than a \grob{} object as
the data for the unit. The next example modifies the previous one to
use a \gPath{}. Now the rectangle's width updates when the width of
the referenced \grob{} changes.

<<results=hide>>=
grid.newpage()
gt <- grid.text("Hi there", name = "sometext")
grid.rect(width = unit(1, "grobwidth", "sometext"))
grid.edit("sometext", label = "Something different")
@

A subtle issue in evaluating \code{"grobwidth"} units involves
establishing the correct graphical context for a \grob{} when
determining its width (if a \grob{} has a viewport in its \code{vp}
slot, that viewport is pushed before the \grob{} is drawn; the same
viewport should be pushed when calculating the \grob{}'s width). To
accomplish this, the generic functions \code{preDrawDetails()},
\code{drawDetails()}, and \code{postDrawDetails()} are provided
(suggestions for better names are welcome). The intent is that pushing
and popping of viewports should occur within the \code{pre} and
\code{post} generics, while the actual drawing takes place in the main
\code{drawDetails()} generic. This design allows the code that
computes a \grob{}'s width to call \code{preDrawDetails()} to
establish the drawing context before performing the calculation. The
following example presents a test case: a \grob{} is created (by
extending a new class to permit specific method definitions), and
methods are provided that set up a particular drawing context for the
\grob{}. These methods are employed both when drawing the \grob{} and
when calculating its width (when drawing a bounding rectangle).

<<results=hide>>=
grid.newpage()
mygrob <- grob(name = "mygrob", cl = "mygrob")
preDrawDetails.mygrob <- function(x)
    pushViewport(viewport(gp = gpar(fontsize = 20)))

drawDetails.mygrob <- function(x, recording = TRUE)
    grid.draw(textGrob("hi there"), recording = FALSE)

postDrawDetails.mygrob <- function(x) popViewport()

widthDetails.mygrob <- function(x) unit(1, "strwidth", "hi there")

grid.draw(mygrob)
grid.rect(width = unit(1, "grobwidth", mygrob))
@

This next example shows a slightly different test case where the
standard \code{preDrawDetails()} and \code{postDrawDetails()} methods
are used, but the \grob{} does possess a \code{vp} slot so these
methods perform meaningful work. Another interesting aspect of this
example is the somewhat more complex \gTree{} that is created. The
\gTree{} includes a \code{childrenvp} specification. When the
\gTree{} is drawn, this viewport is pushed and then ``up''ed before
the children of the \gTree{} are drawn. Consequently, the children of
the \gTree{} can specify a \code{vpPath} to the viewport they should
occupy. This enables the parent \gTree{} to create a collection of
viewports, after which its children select which one to use—a more
efficient arrangement than having each child push and pop its required
viewports, especially when several children are drawn within the same
viewport. A more realistic example of this pattern is presented later.

<<results=hide>>=
grid.newpage()
mygtree <- gTree(name = "mygrob",
                 childrenvp = viewport(name = "labelvp",
                                       gp = gpar(fontsize = 20)),
                 children = gList(textGrob("hi there", name = "label",
                   vp = "labelvp")),
                 cl = "mygtree")
widthDetails.mygtree <- function(x)
    unit(1, "grobwidth", getGrob(x, "label"))

grid.draw(mygtree)
grid.rect(width = unit(1, "grobwidth", mygtree))
@

Constructing a description of a \code{frame} \grob{} must be
performed via \code{packGrob()} and \code{placeGrob()}. The following
example illustrates the construction of a simple frame consisting of
two equal‑sized columns.

<<results = hide>>=
grid.newpage()
fg <- frameGrob(layout = grid.layout(1, 2))
fg <- placeGrob(fg, textGrob("Hi there"), col = 1)
fg <- placeGrob(fg, rectGrob(), col = 2)
grid.draw(fg)
@

This next example constructs a slightly more elaborate frame using
packing.

<<results=hide>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
drawIt <- function(row, col) {
    pushViewport(viewport(layout.pos.col = col, layout.pos.row = row))
    grid.rect(gp = gpar(col = "grey"))
    grid.draw(fg)
    upViewport()
}
fg <- frameGrob()
fg <- packGrob(fg, textGrob("Hi there"))
fg <- placeGrob(fg, rectGrob())
drawIt(1, 1)
fg <- packGrob(fg, textGrob("Hello again"), side = "right")
drawIt(1, 2)
fg <- packGrob(fg, rectGrob(), side = "right", width = unit(1, "null"))
drawIt(2, 2)
@

To allow frames to update when the objects packed within them are
modified, the \code{packGrob()} function (and \code{grid.pack()})
accepts a \code{dynamic} argument. The following extends the previous
example to demonstrate this capability. Another feature illustrated is
the ``non‑strict'' searching employed by the \code{grid.edit()} call;
the \grob{} named \code{"midtext"} is not at the top level but is
nevertheless located. A call such as \code{grid.get("midtext", strict
  = TRUE)} would fail.

<<results=hide>>=
grid.newpage()
fg <- frameGrob()
fg <- packGrob(fg, textGrob("Hi there"))
fg <- placeGrob(fg, rectGrob())
fg <- packGrob(fg, textGrob("Hello again", name = "midtext"),
               side = "right", dynamic = TRUE)
fg <- packGrob(fg, rectGrob(), side = "right", width = unit(1, "null"))
grid.draw(fg)
grid.edit("midtext", label = "something much longer")
@

Several previous examples have involved creating a \gTree{}. The next
example explicitly demonstrates this technique. A \gTree{} is created
with two important components. The \code{childrenvp} is a
\code{vpTree} consisting of a \code{"plotRegion"} viewport to provide
margins around a plot and a \code{"dataRegion"} viewport to define
x‑ and y‑scales. The \code{"dataRegion"} is pushed within the
\code{"plotRegion"}, and both are pushed and then ``up''ed before the
children are drawn. The \code{children} of the \gTree{} are an
\code{xaxis} and a \code{yaxis} both drawn within the
\code{"dataRegion"}, and a \code{rect} drawn around the border of the
\code{"plotRegion"}. A further aspect of this example is the use of
\code{addGrob()} and \code{removeGrob()} to modify the \gTree{}. The
first modification adds a new child to the \gTree{}: a set of points
drawn within the \code{"dataRegion"}. The second modification adds
another set of points with a different plotting symbol (note that this
second set is given a name to facilitate later identification among
the children of the \gTree{}). The final modification removes the
second set of points from the \gTree{}.

<<results=hide>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
drawIt <- function(row, col) {
    pushViewport(viewport(layout.pos.col = col, layout.pos.row = row))
    grid.rect(gp = gpar(col = "grey"))
    grid.draw(gplot)
    upViewport()
}
gplot <- gTree(x = NULL, y = NULL,
               childrenvp = vpTree(
                 plotViewport(c(5, 4, 4, 2), name = "plotRegion"),
                 vpList(viewport(name = "dataRegion"))),
               children = gList(
                 xaxisGrob(vp = "plotRegion::dataRegion"),
                 yaxisGrob(vp = "plotRegion::dataRegion"),
                 rectGrob(vp = "plotRegion")))
drawIt(1, 1)
gplot <- addGrob(gplot, pointsGrob(vp = "plotRegion::dataRegion"))
drawIt(1, 2)
gplot <- addGrob(gplot, pointsGrob(name = "data1", pch = 2,
                                   vp = "plotRegion::dataRegion"))
drawIt(2, 1)
gplot <- removeGrob(gplot, "data1")
drawIt(2, 2)
@

The next example provides a simple demonstration of saving and loading
\grid{} \grob{}s. It also serves as a reminder that \grob{}s are
copied like ordinary \R{} objects.

<<results=hide>>=
gplot <- gTree(x = NULL, y = NULL,
               childrenvp = vpTree(
                 plotViewport(c(5, 4, 4, 2), name = "plotRegion"),
                   vpList(viewport(name = "dataRegion"))),
               children = gList(
                 xaxisGrob(vp = "plotRegion::dataRegion"),
                 yaxisGrob(vp = "plotRegion::dataRegion"),
                 rectGrob(vp = "plotRegion")))
save(gplot, file = "gplot1")
gplot <- addGrob(gplot, pointsGrob(vp = "plotRegion::dataRegion"))
save(gplot, file = "gplot2")
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
pushViewport(viewport(layout.pos.col = 1))
load("gplot1")
grid.draw(gplot)
popViewport()
pushViewport(viewport(layout.pos.col = 2))
load("gplot2")
grid.draw(gplot)
popViewport()
@

This next example demonstrates that a \gPath{} can be used to access
the children of a \gTree{} when editing. This is the \code{editGrob()}
equivalent of an earlier example that used \code{grid.edit()}. One
useful application of this API is the ability to modify the appearance
of very specific elements within a large, complex graphical object by
editing the \code{gp} slot of a child (or a descendant) of a
\gTree{}.

<<results = hide>>=
myplot <- gTree(name = "myplot",
                children = gList(
                  rectGrob(name = "box", gp = gpar(col = "grey")),
                  xaxisGrob(name = "xaxis")))
myplot <- editGrob(myplot, gPath = "xaxis", at = 1:10/11)
myplot <- editGrob(myplot, gPath = "xaxis::labels", label = round(1:10/11, 2))
myplot <- editGrob(myplot, gPath = "xaxis::labels", y = unit(-1, "lines"))
grid.newpage()
pushViewport(viewport(w = .5, h = .5))
grid.draw(myplot)
@

The following example illustrates the use of \code{getGrob()} and
\code{grid.get()} (along with \gPath{}s) to retrieve \grob{}s.

<<results = hide>>=
myplot <- gTree(name = "myplot",
                children = gList(
                  rectGrob(name = "box", gp = gpar(col = "grey")),
                  xaxisGrob(name = "xaxis")))
getGrob(myplot, "xaxis")
myplot <- editGrob(myplot, gPath="xaxis", at=1:10/11)
getGrob(myplot, "xaxis::labels")
grid.newpage()
pushViewport(viewport(w=.5, h=.5))
grid.draw(myplot)
grid.get("myplot")
grid.get("myplot::xaxis")
grid.get("myplot::xaxis::labels")
@

An additional API exists for (re)setting children of a \gTree{} or any
drawn \grob{}. This is not intended for general user use, but provides
a straightforward mechanism for developers to modify the structure of
a \gTree{} by performing steps such as:

\begin{verbatim}
grob <- getGrob(<spec>)
<modify grob>
setGrob(<spec>, grob)
\end{verbatim}

This approach is employed in the implementation of packing and placing
grobs. The example below shows simple usage of the \code{setGrob()}
and \code{grid.set()} functions to replace children of a \gTree{}
with different \grob{}s. Note that currently such replacement is only
permitted if the new \grob{} has the same name as the old \grob{}.

<<results=hide>>=
myplot <- gTree(name = "myplot",
                children = gList(rectGrob(name = "box", gp = gpar(col = "grey")),
                  xaxisGrob(name = "xaxis")))
myplot <- setGrob(myplot, "xaxis", rectGrob(name = "xaxis"))
grid.newpage()
pushViewport(viewport(w = .5, h = .5))
grid.draw(myplot)
grid.set("myplot::xaxis", xaxisGrob(name = "xaxis", at = 1:3/4))
grid.set("myplot::xaxis::labels",
         textGrob(name = "labels", x = unit(1:3/4, "native"),
                  y = unit(-1, "lines"), label = letters[1:3]))
myplot <- setGrob(grid.get("myplot"), "xaxis::labels",
                  circleGrob(name = "labels"))
grid.newpage()
pushViewport(viewport(w = .5, h = .5))
grid.draw(myplot)
@

The next example illustrates more complex use of the add/remove
facilities for modifying \grob{}s. Again, \code{addGrob()} and
\code{removeGrob()} are for constructing descriptions of graphical
objects, while \code{grid.add()} and \code{grid.remove()} modify drawn
output. Of particular note are the last two lines involving
\code{grid.remove()}. First, there are multiple \grob{}s on the
display list with the same name; the example affects only the first
one encountered. This behavior could be extended to affect the display
list ``globally'' (for children of \gTree{}s, duplicate names are not
allowed, so the issue does not arise). The final line is interesting
because it entirely removes the \grob{} named \code{"plot1"} from the
display list (or, more precisely, the first instance of a \grob{}
called \code{"plot1"} on the display list).

<<results=hide>>=
drawIt <- function(row, col) {
  pushViewport(viewport(layout.pos.col = col, layout.pos.row = row))
  grid.rect(gp = gpar(col = "grey"))
  grid.draw(gplot)
  upViewport()
}
gplot <- gTree(name = "plot1",
               childrenvp = vpTree(
                 plotViewport(c(5, 4, 4, 2), name = "plotRegion"),
                 vpList(viewport(name = "dataRegion"))),
               children = gList(
                 xaxisGrob(name = "xaxis", vp = "plotRegion::dataRegion"),
                 yaxisGrob(name = "yaxis", vp = "plotRegion::dataRegion"),
                 rectGrob(name = "box", vp = "plotRegion")))
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
drawIt(1, 1)
grid.add("plot1", pointsGrob(0.5, 0.5, name = "data1",
                             vp = "plotRegion::dataRegion"))
grid.add("plot1::xaxis",
         textGrob("X Axis", y = unit(-2, "lines"), name = "xlab"))
grid.edit("plot1::xaxis::xlab", y = unit(-3, "lines"))
gplot <- grid.get("plot1")
gplot <- addGrob(gplot, gPath = "yaxis",
                 textGrob("Y Axis", x = unit(-3, "lines"), rot = 90,
                          name = "ylab"))
drawIt(1, 2)
gplot <- removeGrob(gplot, "xaxis::xlab")
drawIt(2, 1)
grid.remove("plot1::data1")
grid.remove("plot1")
@

The next example provides a \code{grid.place()} and
\code{grid.pack()} equivalent of an earlier example that used
\code{placeGrob()} and \code{packGrob()}. The notable feature is that
each action is immediately reflected in the output as it occurs.

<<results=hide>>=
grid.newpage()
grid.frame(name = "myframe", layout = grid.layout(1, 2))
grid.place("myframe", textGrob("Hi there"), col = 1)
grid.place("myframe", rectGrob(), col = 2)
grid.newpage()
grid.frame(name = "frame2")
grid.pack("frame2", textGrob("Hi there"))
grid.place("frame2", rectGrob())
grid.pack("frame2", textGrob("Hello again"), side = "right")
grid.pack("frame2", rectGrob(), side = "right", width = unit(1, "null"))
@
\end{document}