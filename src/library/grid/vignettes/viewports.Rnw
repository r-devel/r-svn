% File src/library/grid/vignettes/viewports.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

\usepackage{Rd}

% \VignetteIndexEntry{Working with viewports}

\newcommand{\grid}{\pkg{grid}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{Working with \grid{} Viewports}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(stats) # for runif()
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

This document describes several features of \grid{} viewports that
facilitate navigating among multiple regions on a device without
needing to recreate those regions. It also presents a mechanism by
which a complex plotting function can grant users access to all of the
regions it creates during plotting.

\section*{The viewport tree}

\grid{} maintains a hierarchical tree of pushed viewports on each
device. The function \code{upViewport()} operates similarly to
\code{popViewport()} except that it does not remove viewports from the
viewport tree. For example, the following code pushes a viewport,
navigates back to the top‑level viewport, and pushes another viewport,
leaving the first viewport intact.

<<>>=
pushViewport(viewport())
upViewport()
pushViewport(viewport())
@
Two viewports now reside directly beneath the top‑level viewport.
This immediately introduces an ambiguity: if we navigate back to the
top‑level and attempt to revisit one of the viewports, how can we
specify which one we desire? The solution is that viewports possess a
\code{name} argument\footnote{The print method for viewports displays
  the viewport name within square brackets. Try typing
  \code{current.viewport()}.}. This name, combined with the
\code{downViewport()} function, enables navigation back down to
specific viewports within the tree. Consider the following example,
which pushes two viewports named \code{"A"} and \code{"B"}, then
navigates from the top level to viewport \code{"A"}.

<<echo=FALSE, results=hide>>=
grid.newpage()

<<>>=
pushViewport(viewport(name = "A"))
upViewport()
pushViewport(viewport(name = "B"))
upViewport()
downViewport("A")
@

The \code{downViewport()} function searches downward from the current
position in the tree. The \code{seekViewport()} function is similar but
always begins its search from the top‑level viewport. In the previous
example we ended in viewport \code{"A"}; the following command
navigates directly from \code{"A"} to \code{"B"}.

<<>>=
seekViewport("B")
@

The function \code{current.vpTree()} provides a textual representation
of the current viewport tree.

<<>>=
current.vpTree()
@

\section*{Viewport stacks, lists, and trees}

It is possible to create descriptions of multiple viewports
\emph{and their relationships} simultaneously. The functions
\code{vpStack()}, \code{vpList()}, and \code{vpTree()} construct,
respectively, a stack, a list, or a tree of viewport descriptions.
These composite descriptions can then be pushed as a unit: viewports in
a stack are pushed in series, viewports in a list are pushed in
parallel, and for a tree the parent is pushed first, then the children
are pushed in parallel. The following simple example demonstrates one
use of this feature: a \grid{} rectangle is drawn \emph{two} viewports
below the current level by supplying a stack of viewports via its
\code{vp} argument.

<<vpstackguts>>=
vp <- viewport(width = 0.5, height = 0.5)
grid.rect(vp = vpStack(vp, vp))
<<echo=FALSE, fig=TRUE>>=
grid.rect(gp = gpar(col = "grey"))
<<vpstackguts>>
@

\section*{Viewport paths}

The previous example illustrates a subtle feature of \grid{}'s viewport
tree: the same viewport, \emph{with the same name}, was pushed twice
(in series). This shows that viewport names need only be unique among
viewports sharing the same parent. This design permits convenient
reuse of viewport names, especially in repetitive plot arrangements.
For example, in a \lattice{}-style plot, each panel could contain a
viewport named \code{"strip"} representing the strip region.

This design introduces a further ambiguity because multiple viewports
with identical names may exist within the tree\footnote{\code{downViewport()}
  and \code{seekViewport()} stop at the first match they encounter
  (the search is currently depth‑first).}. This ambiguity can be
resolved by using the \code{vpPath()} function to generate a
specification of a stack of viewports that must be matched by name.
This path can be supplied to either \code{downViewport()} or
\code{seekViewport()}, as illustrated in the following example. Note
that we call \code{current.vpTree(FALSE)} to view the current viewport
tree \emph{only from the current viewport downward}.

<<echo=FALSE, results=hide>>=
grid.newpage()

<<>>=
pushViewport(viewport(name = "A"))
pushViewport(viewport(name = "B"))
pushViewport(viewport(name = "A"))
@

A simple seek for \code{"A"} locates the first \code{"A"} (just below
the top‑level viewport).

<<>>=
seekViewport("A")
current.vpTree(FALSE)
@

By specifying a \code{vpPath}, we can reach the \code{"A"} directly
beneath viewport \code{"B"}.

<<>>=
seekViewport(vpPath("B", "A"))
current.vpTree(FALSE)
@

A viewport path is conceptually a concatenation of several names using
a path separator (currently \code{::}).

<<>>=
vpPath("A", "B")
@

For interactive use, the path may be supplied as a simple string, but
this practice is not recommended for scripted code because the path
separator could change in future versions of \grid{}. As an example,
the following two commands are currently equivalent.

<<eval=FALSE>>=
seekViewport(vpPath("A", "B"))
seekViewport("A::B")
@

\section*{An example}

In this section we present a simple example that demonstrates how
these viewport features can be employed together. The goal is to
produce a basic scatterplot. We begin with some random data.

<<>>=
x <- runif(10)
y <- runif(10)
@

Because we will establish scales appropriate for these data, we
compute suitable ranges now.

<<>>=
xscale <- extendrange(x)
yscale <- extendrange(y)
@

We now create a collection of viewports that will be useful for
constructing the plot. The first viewport contains a layout that
divides the drawing region into several rows and columns. The left and
right columns and the top and bottom rows provide space for axes and
labels, while the central cell furnishes a region for plotting the
data. The diagram below the code illustrates the layout we create.

<<>>=
top.vp <-
    viewport(layout=grid.layout(3, 3,
             widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
             heights=unit(c(5, 1, 4), c("lines", "null", "lines"))))

<<echo=FALSE, fig=TRUE>>=
grid.show.layout(viewport.layout(top.vp))
@

Next we define a set of viewports that will occupy different areas
within this layout, corresponding to the margins for axes and labels,
and the plotting region itself.

<<>>=
margin1 <- viewport(layout.pos.col = 2, layout.pos.row = 3,
                    name = "margin1")
margin2 <- viewport(layout.pos.col = 1, layout.pos.row = 2,
                    name = "margin2")
margin3 <- viewport(layout.pos.col = 2, layout.pos.row = 1,
                    name = "margin3")
margin4 <- viewport(layout.pos.col = 3, layout.pos.row = 2,
                    name = "margin4")
plot <- viewport(layout.pos.col = 2, layout.pos.row = 2,
                 name = "plot", xscale = xscale, yscale = yscale)
@

Note that we have not yet pushed any of these viewports; no regions
exist on the output device. We first arrange the viewports into a tree
structure, with \code{top.vp} as the parent node and all other
viewports as its children.

<<>>=
splot <- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
@

Now we can push this entire tree of viewports to create all the
distinct areas required for the scatterplot. The result of this
operation leaves us positioned within the \code{plot} viewport.

<<viewports>>=
pushViewport(splot)
@

We can now navigate to whichever viewport we need and draw the
various elements of the plot\footnote{The named viewports we created
  are outlined with grey rectangles as a visual guide.}.

<<grid, echo=FALSE, eval=FALSE>>=
labelvp <- function(name) {
    seekViewport(name)
    grid.rect(gp = gpar(col = "grey", lwd = 5))
    grid.rect(x = 0, y = 1, width = unit(1, "strwidth", name) + unit(2, "mm"),
              height = unit(1, "lines"), just = c("left", "top"),
              gp = gpar(fill = "grey", col = NULL))
    grid.text(name, x = unit(1, "mm"), y = unit(1, "npc") - unit(1, "mm"),
              just = c("left", "top"), gp = gpar(col = "white"))
}
labelvp("plot")
labelvp("margin1")
labelvp("margin2")
labelvp("margin3")
labelvp("margin4")
@

The data symbols and axes are drawn relative to the plot region:

<<plot, eval=FALSE>>=
seekViewport("plot")
grid.points(x, y)
grid.xaxis()
grid.yaxis()
grid.rect()
@

The x‑axis label is placed in margin 1:

<<margin1, eval=FALSE>>=
seekViewport("margin1")
grid.text("Random X", y = unit(1, "lines"))
@

The y‑axis label is drawn in margin 2 (the final output appears on the
next page).

<<margin2, eval=FALSE>>=
seekViewport("margin2")
grid.text("Random Y", x = unit(1, "lines"), rot = 90)

<<echo=FALSE, results=hide, fig=TRUE>>=
pushViewport(viewport(w = 0.9, h = 0.9))
<<viewports>>
<<grid>>
<<plot>>
<<margin1>>
<<margin2>>
@

As a final step, we navigate back to the top‑level viewport (i.e., the
viewport we started from)\footnote{Here we have used \code{0} to
  indicate “navigate to the top‑level viewport.” When writing code
  that may be used by others (e.g., a graphical component that could
  be embedded within another plot), it would be necessary to specify
  an exact number of viewports to navigate upward. In this case, that
  number would be {\tt} 2. The \code{downViewport()} function returns
  the number of viewports it descended, so a general solution takes
  the form: \code{depth <- downViewport("avp"); upViewport(depth)}.}.

<<>>=
upViewport(0)
@

Thus far the example merely illustrates an alternative method for
constructing this type of plot. The same output could have been
achieved using \code{pushViewport()} and \code{popViewport()}. The
difference is that we retain all the viewports in the \grid{} viewport
tree, and they remain addressable by name. Consequently, a user can
seek any of the viewports employed during plot construction (by name)
and add annotations, employ \code{grid.locator()}, or perform other
operations. For example, a user could add a title with the following
commands.

<<annguts, eval=FALSE>>=
seekViewport("margin3")
grid.text("The user adds a title!", gp = gpar(fontsize = 20))

<<echo=FALSE, results=hide, fig=TRUE>>=
pushViewport(viewport(w = 0.9, h = 0.9))
<<viewports>>
<<grid>>
<<plot>>
<<margin1>>
<<margin2>>
<<annguts>>
popViewport(0)
@

\end{document}