%\VignetteEncoding{UTF-8}
% File src/library/grid/vignettes/viewports.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001–2026 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}
\usepackage{Rd}

%\VignetteIndexEntry{Working with viewports}
%\VignettePackage{grid}

\newcommand{\grid}{\pkg{grid}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{Working with \grid{} Viewports}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(stats)   # for runif()
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

\section*{Introduction}
This vignette describes features of \grid{} viewports that make it easy
to navigate between multiple regions on a device without recreating
them. It also shows how complex plotting functions can provide users
with access to all regions created during plotting.

\section*{The Viewport Tree}
\grid{} maintains a tree of pushed viewports on each device. The
\code{upViewport()} function works like \code{popViewport()}, except that
it does not remove viewports from the tree. For example:

<<>>=
pushViewport(viewport())
upViewport()
pushViewport(viewport())
@

This results in two viewports directly beneath the top‑level viewport.
To revisit a specific viewport, use the \code{name} argument when
creating viewports and navigate with \code{downViewport()}. For example:

<<echo=FALSE, results=hide>>=
grid.newpage()
<<>>=
pushViewport(viewport(name = "A"))
upViewport()
pushViewport(viewport(name = "B"))
upViewport()
downViewport("A")
@

The \code{downViewport()} function searches downward from the current
position. The \code{seekViewport()} function is similar but always
starts from the top level. For example:

<<>>=
seekViewport("B")
@

The function \code{current.vpTree()} provides a textual view of the
current viewport tree:

<<>>=
current.vpTree()
@

\section*{Viewport Stacks, Lists, and Trees}
It is possible to create multiple viewport descriptions and their
relationships using \code{vpStack()}, \code{vpList()}, and
\code{vpTree()}. These allow pushing multiple viewports at once:
- A stack pushes viewports in series.  
- A list pushes viewports in parallel.  
- A tree pushes the parent then its children in parallel.  

Example: drawing a rectangle two viewports below the current level:

<<vpstackguts>>=
vp <- viewport(width = 0.5, height = 0.5)
grid.rect(vp = vpStack(vp, vp))
<<echo=FALSE, fig=TRUE>>=
grid.rect(gp = gpar(col = "grey"))
<<vpstackguts>>
@

\section*{Viewport Paths}
Viewport names only need to be unique among siblings. This allows reuse
of convenient names in repetitive plot arrangements (e.g., each panel in
a \lattice{} plot may have a viewport called \code{"strip"}).

Ambiguity arises when multiple viewports share the same name. Functions
\code{downViewport()} and \code{seekViewport()} stop at the first match
(depth‑first search). To resolve ambiguity, use \code{vpPath()} to
specify a stack of viewports by name. This path can then be passed to
\code{downViewport()} or \code{seekViewport()}. For example:

<<echo=FALSE, results=hide>>=
grid.newpage()
@


<<>>=
pushViewport(viewport(name = "A"))
pushViewport(viewport(name = "B"))
pushViewport(viewport(name = "A"))
@

When seeking just \code{"A"}, the first match is found (just below the top‑level viewport):

<<>>=
seekViewport("A")
current.vpTree(FALSE)
@

By specifying a \code{vpPath}, we can target the \code{"A"} directly beneath viewport \code{"B"}:

<<>>=
seekViewport(vpPath("B", "A"))
current.vpTree(FALSE)
@

A viewport path is conceptually a concatenation of names using a path separator (currently \code{::}):

<<>>=
vpPath("A", "B")
@

For interactive use, the path can be specified as a string, but this is not recommended in scripts in case the separator changes in future versions of \grid{}. For example:

<<eval=FALSE>>=
seekViewport(vpPath("A", "B"))
seekViewport("A::B")
@

\section*{Example: Scatterplot with Viewports}
We now demonstrate how these viewport features can be combined to construct a scatterplot.

Generate random data:

<<>>=
x <- runif(10)
y <- runif(10)
@

Establish scales:

<<>>=
xscale <- extendrange(x)
yscale <- extendrange(y)
@

Define a layout viewport dividing the drawing region into rows and columns:

<<>>=
top.vp <-
    viewport(layout=grid.layout(3, 3,
             widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
             heights=unit(c(5, 1, 4), c("lines", "null", "lines"))))

<<echo=FALSE, fig=TRUE>>=
grid.show.layout(viewport.layout(top.vp))
@

Define child viewports for margins and plot region:

<<>>=
margin1 <- viewport(layout.pos.col = 2, layout.pos.row = 3, name = "margin1")
margin2 <- viewport(layout.pos.col = 1, layout.pos.row = 2, name = "margin2")
margin3 <- viewport(layout.pos.col = 2, layout.pos.row = 1, name = "margin3")
margin4 <- viewport(layout.pos.col = 3, layout.pos.row = 2, name = "margin4")
plot <- viewport(layout.pos.col = 2, layout.pos.row = 2,
                 name = "plot", xscale = xscale, yscale = yscale)
@

Arrange into a tree structure:

<<>>=
splot <- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
@

Push the tree to create all regions:

<<viewports>>=
pushViewport(splot)
@

Navigate to viewports and draw elements\footnote{Named viewports are shown as grey rectangles for clarity.}:

<<grid, echo=FALSE, eval=FALSE>>=
labelvp <- function(name) {
    seekViewport(name)
    grid.rect(gp = gpar(col = "grey", lwd = 5))
    grid.rect(x = 0, y = 1, width = unit(1, "strwidth", name) + unit(2, "mm"),
              height = unit(1, "lines"), just = c("left", "top"),
              gp = gpar(fill = "grey", col = NULL))
    grid.text(name, x = unit(1, "mm"), y = unit(1, "npc") - unit(1, "mm"),
              just = c("left", "top"), gp = gpar(col = "white"))
}
labelvp("plot")
labelvp("margin1")
labelvp("margin2")
labelvp("margin3")
labelvp("margin4")
@

Draw data and axes in the plot region:

<<plot, eval=FALSE>>=
seekViewport("plot")
grid.points(x, y)
grid.xaxis()
grid.yaxis()
grid.rect()
@

Add axis labels in margins:

<<margin1, eval=FALSE>>=
seekViewport("margin1")
grid.text("Random X", y = unit(1, "lines"))
@

<<margin2, eval=FALSE>>=
seekViewport("margin2")
grid.text("Random Y", x = unit(1, "lines"), rot = 90)
@

Final output:

<<echo=FALSE, results=hide, fig=TRUE>>=
pushViewport(viewport(w = 0.9, h = 0.9))
<<viewports>>
<<grid>>
<<plot>>
<<margin1>>
<<margin2>>
@

\section*{Navigating Back}
Navigate back to the top‑level viewport:

<<>>=
upViewport(0)
@

This approach differs from using only \code{pushViewport()} and
\code{popViewport()} because all viewports remain in the \grid{}
viewport tree and are addressable by name. This allows users to seek
viewports later to add annotations or interact with the plot. For
example, adding a title:

<<annguts, eval=FALSE>>=
seekViewport("margin3")
grid.text("The user adds a title!", gp = gpar(fontsize = 20))
@

<<echo=FALSE, results=hide, fig=TRUE>>=
pushViewport(viewport(w = 0.9, h = 0.9))
<<viewports>>
<<grid>>
<<plot>>
<<margin1>>
<<margin2>>
<<annguts>>
popViewport(0)
@

\end{document}

