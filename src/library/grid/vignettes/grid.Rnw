% File src/library/grid/vignettes/grid.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

\usepackage{Rd}

% \VignetteIndexEntry{Introduction to grid}
% \VignettePackage{grid}

% Definitions
\newcommand{\slan}{{\sffamily S}}
\newcommand{\rlan}{{\sffamily R}}
\newcommand{\grid}{\pkg{grid}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\newcommand{\I}[1]{#1}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{\grid{} Graphics}
\author{Paul Murrell}

\begin{document}

\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(graphics) # for par
library(stats) # for rnorm
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

\grid{} is a low‑level graphics system offering extensive control and
flexibility over the appearance and arrangement of graphical output.
Unlike higher‑level plotting systems, \grid{} does not provide
pre‑defined functions that generate complete plots. Instead, it
furnishes a foundation upon which such high‑level functions can be
built (e.g., the \lattice{} and \CRANpkg{ggplot2} packages). It also
provides the means to customize and manipulate \lattice{} output, to
create high‑level plots or non‑statistical images from scratch, and to
add sophisticated annotations to base graphics output (see the
\CRANpkg{gridBase} package).

This document introduces the fundamental concepts underpinning the
\grid{} package: \textbf{viewports}, \textbf{units}, and
\textbf{graphical parameters}. Several illustrative examples are
included to demonstrate the capabilities of \grid{} and the techniques
for achieving them.

The description of these core concepts assumes the following general
approach to constructing a statistical graphic (plot). One must be able to:

\begin{enumerate}
\item Create and control distinct graphical regions and coordinate
  systems.
\item Direct graphical output into a chosen graphical region and
  coordinate system.
\item Generate graphical output (lines, points, text, \ldots{}) while
  controlling its visual attributes (colour, line type, line width,
  \ldots{}).
\end{enumerate}

\section{Creating and Controlling Graphics Regions and Coordinate Systems}

Within \grid{}, an arbitrary number of graphical regions may be
defined. Such a region is termed a \emph{viewport} and is created
using the \code{viewport()} function. A viewport may be positioned
anywhere on a graphics device (page, window, \ldots{}), may be rotated,
and may have its drawing clipped to its boundaries. The following code
describes a viewport that is centred on the page, occupies half the
page width and one quarter of the page height, and is rotated
$45^{\circ}$; Figure \ref{figure:viewport} presents a diagram of this
viewport.

<<eval=FALSE>>=
viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=45)
<<viewport, echo=FALSE, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.show.viewport(viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25,
                            angle = 45))
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-viewport}
}
\end{center}
\caption{
  \label{figure:viewport}
  A diagram of a simple \grid{} viewport (produced using the
  \code{grid.show.viewport()} function).}
\end{figure}

The object returned by \code{viewport()} is merely a \emph{description}
of a graphical region. An actual graphics region is instantiated on a
device only when a viewport is ``pushed'' onto that device using the
\code{pushViewport()} function. Each device maintains a single
``current viewport'' (by default the entire device surface) and a
hierarchical ``tree'' of viewports that have been pushed. The current
viewport is a node on this tree. \code{pushViewport()} adds a viewport
as a leaf of the tree: the previous current viewport becomes its
parent, and the new leaf becomes the current viewport. The
\code{popViewport()} function removes the current viewport (and all
its descendants) from the tree; the parent of the removed node then
becomes the current viewport. \code{upViewport()} behaves like
\code{popViewport()} in setting the current viewport but does not
prune the previous current viewport from the tree. The
\code{downViewport()} function navigates down the tree to a viewport
specified by name (it adds no new viewports). Consequently, there is
always exactly one graphics region selected for drawing, but one may
return to any previously defined region via appropriate
push/pop/up/down operations.

As an illustration, the following code creates a graphics region in
the top‑left corner of the page via \code{pushViewport()}. This
viewport is assigned the name \code{"vp1"}. Some drawing is performed,
then \code{upViewport()} returns to the root of the viewport tree.
Next, a second region is created in the bottom‑right corner (again via
\code{pushViewport()}) and more drawing occurs. Finally,
\code{upViewport()} returns to the root, and \code{downViewport()}
navigates back to the first region to perform additional drawing (see
Figure \ref{figure:viewports}).

<<pushviewports, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.rect(gp = gpar(lty = "dashed"))
vp1 <- viewport(x = 0, y = 0.5, w = 0.5, h = 0.5,
                just = c("left", "bottom"), name = "vp1")
vp2 <- viewport(x = 0.5, y = 0, w = 0.5, h = 0.5,
                just = c("left", "bottom"))
pushViewport(vp1)
grid.rect(gp = gpar(col = "grey"))
grid.text("Some drawing in graphics region 1", y = 0.8)
upViewport()
pushViewport(vp2)
grid.rect(gp = gpar(col = "grey"))
grid.text("Some drawing in graphics region 2", y = 0.8)
upViewport()
downViewport("vp1")
grid.text("MORE drawing in graphics region 1", y = 0.2)
popViewport()
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-pushviewports}
}
\end{center}
\caption{\label{figure:viewports}
        Defining and drawing in multiple graphics regions.}
\end{figure}

When multiple viewports are pushed onto the viewport tree, each leaf
viewport is positioned and sized relative to its parent viewport. The
following code exemplifies this: a viewport is defined as one‑quarter
the size of its parent (half the width and half the height). This
viewport is pushed twice. The first push occurs with the root viewport
(entire device) as parent, so the viewport occupies one quarter of the
page. The second push occurs with the first viewport as parent, so the
new viewport occupies one quarter of \emph{that} viewport's area.
Figure \ref{figure:vpstack} shows the resulting output.

<<vpstack, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.rect(gp = gpar(lty = "dashed"))
vp <- viewport(width = 0.5, height = 0.5)
pushViewport(vp)
grid.rect(gp = gpar(col = "grey"))
grid.text("quarter of the page", y = 0.85)
pushViewport(vp)
grid.rect()
grid.text("quarter of the\nprevious viewport")
popViewport(2)
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-vpstack}
}
\end{center}
\caption{\label{figure:vpstack}
        The result of pushing the same viewport onto the viewport
stack twice.}
\end{figure}

Each viewport possesses several associated coordinate systems. The
complete set is described in Table \ref{table:coords}, but four primary
types may be distinguished: absolute coordinates (e.g., \code{"inches"},
\code{"cm"}) specify locations and sizes in physical units independent of
device dimensions; normalised coordinates (e.g., \code{"npc"}) express
locations and sizes as proportions of the current viewport's
dimensions; relative coordinates (\code{"native"}) allow locations and
sizes relative to user‑defined x‑ and y‑ranges; and referential
coordinates (e.g., \code{"strwidth"}) base measurements on the
dimensions of other graphical objects.

The coordinate system for relative (\code{"native"}) coordinates may be
explicitly specified; all other coordinate systems are implicitly
defined based on the viewport's position and size and/or the sizes of
other graphical objects.

\begin{table}[p]
\begin{center}
\begin{tabular}{l l} \hline
{\bf Coordinate} & \\
{\bf System Name} & {\bf Description} \\ \hline
\code{"npc"} & \parbox[t]{3in}{Normalised Parent Coordinates.  Treats
the bottom‑left corner of the current
viewport as $(0, 0)$ and the top‑right corner
as $(1,1)$. }  \\
\code{"native"} & \parbox[t]{3in}{Locations and sizes are expressed
relative to the user‑defined x‑ and y‑scales of the current viewport.} \\
\code{"inches"} & \parbox[t]{3in}{Locations and sizes are in physical
inches.  For locations, $(0,0)$ is at the bottom‑left
of the viewport.} \\
\code{"cm"} & \parbox[t]{3in}{Analogous to \code{"inches"}, but in
centimetres.} \\
\code{"mm"} & \parbox[t]{3in}{Millimetres.} \\
\code{"points"} & \parbox[t]{3in}{Points.  There are 72.27 points per inch.} \\
\code{"bigpts"} & \parbox[t]{3in}{Big points. There are 72 big points per inch.} \\
\code{"picas"} & \parbox[t]{3in}{\I{Picas}.  There are 12 points per pica.} \\
\code{"dida"} & \parbox[t]{3in}{\I{Dida}.  1157 \I{dida} equals 1238 points. } \\
\code{"cicero"} & \parbox[t]{3in}{Cicero.  There are 12 \I{dida} per \I{cicero}. } \\
\code{"scaledpts"} & \parbox[t]{3in}{Scaled points. There are 65536 scaled
points per point. } \\
\code{"char"} & \parbox[t]{3in}{Locations and sizes are expressed as
multiples of the current nominal \code{fontheight}.} \\
\code{"lines"} & \parbox[t]{3in}{Locations and sizes are expressed as
multiples of the height of a line of text
 (dependent on both the current \code{fontsize} and
the current \code{lineheight}).} \\
\code{"snpc"} & \parbox[t]{3in}{Square Normalised Parent Coordinates.
Locations and sizes are expressed as a proportion of the \emph{smaller}
of the width and height of the current viewport.} \\
\code{"strwidth"} & \parbox[t]{3in}{Locations and sizes are expressed
as multiples of the width of a given string (dependent on the string
and the current \code{fontsize}).} \\
\code{"strheight"} & \parbox[t]{3in}{Locations and sizes are expressed
as multiples of the height of a given string (dependent on the string
and the current \code{fontsize}).} \\
\code{"grobwidth"} & \parbox[t]{3in}{Locations and sizes are expressed
as multiples of the width of a given graphical object (dependent on
the current state of that object). } \\
\code{"grobheight"} & \parbox[t]{3in}{Locations and sizes are expressed
as multiples of the height of a given graphical object (dependent on
the current state of that object). } \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:coords}
         The complete set of coordinate systems available in \grid{}
viewports.}
\end{table}

\section{Directing Graphics Output into Different Graphics Regions
and Coordinate Systems}

Graphics output is always produced relative to the current viewport on
the current device. Selecting a particular region thus involves
navigating the viewport tree via push, pop, up, and down operations.
Additionally, each viewport offers multiple coordinate systems; one
must also choose the appropriate coordinate system for the intended
drawing.

The choice of coordinate system within the current viewport is made
using the \code{unit()} function. This function creates an object that
combines a numeric value with a coordinate system identifier (plus
auxiliary information for certain coordinate systems). The following
examples, drawn from the \code{help(unit)} page, illustrate the use of
units:

<<units>>=
unit(1, "npc")
unit(1:3/4, "npc")
unit(1:3/4, "npc")[2]
unit(1:3/4, "npc") + unit(1, "inches")
min(unit(0.5, "npc"), unit(1, "inches"))
unit.c(unit(0.5, "npc"), unit(2, "inches") + unit(1:3/4, "npc"),
       unit(1, "strwidth", "hi there"))
@
Observe that unit objects behave similarly to numeric vectors. They
can be indexed, support basic arithmetic operations (including
\code{min} and \code{max}), and have several unit‑specific analogues of
common functions (e.g., \code{unit.c}, \code{unit.rep},
\code{unit.length}, \code{unit.pmin}, and \code{unit.pmax}).

\grid{} functions that accept arguments specifying locations and sizes
typically assume a default coordinate system, most often
\code{"npc"}. That is, a raw numeric value \code{x} is implicitly
interpreted as \code{unit(x, "npc")}. The \code{viewport()} function
is one that assumes \code{"npc"} coordinates; consequently, all
viewport examples thus far have used only \code{"npc"} coordinates to
position viewports. It is, however, possible to position viewports
using any of the coordinate systems listed in Table \ref{table:coords}.

The following example utilizes \code{"npc"}, \code{"native"},
\code{"inches"}, and \code{"strwidth"} coordinates. It first pushes a
viewport with a user‑defined x‑scale, then pushes a second viewport
centred at the x‑value 60 (in native coordinates) and midway up the
first viewport, with a height of 3 inches\footnote{For verification:
  the scaling factor is $3.5/6$, so the rectangle in the figure should
  measure 1.75 inches (4.445 cm) in height.} and a width equal to that
of the text ``coordinates for everyone''. Figure \ref{figure:vpcoords}
shows the resulting output.

<<vpcoords, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
pushViewport(viewport(y = unit(3, "lines"), width = 0.9, height = 0.8,
                      just = "bottom", xscale = c(0, 100)))
grid.rect(gp = gpar(col = "grey"))
grid.xaxis()
pushViewport(viewport(x = unit(60, "native"), y = unit(0.5, "npc"),
                      width = unit(1, "strwidth", "coordinates for everyone"),
                      height = unit(3, "inches")))
grid.rect()
grid.text("coordinates for everyone")
popViewport(2)
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-vpcoords}
}
\end{center}
\caption{\label{figure:vpcoords}
        A viewport positioned using a variety of coordinate systems.}
\end{figure}

\clearpage
\subsection{Layouts}

\grid{} offers an alternative mechanism for positioning viewports
relative to one another based on \emph{layouts}\footnote{The primary
  reference for layouts is \cite{murrell:1999}.  Layouts in \grid{}
  extend the concept to permit a wider range of units for specifying
  row heights and column widths. \grid{} also differs in how children
  of a layout specify their position within it.}. A layout may be
associated with any viewport. Any viewport pushed immediately after a
viewport containing a layout may specify its position with respect to
that layout. In the following simple example, a viewport with a layout
of 4 rows and 5 columns is pushed; then a second viewport is pushed
occupying the second and third columns of the third row of that layout.

<<vplayout, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
pushViewport(viewport(layout = grid.layout(4, 5)))
grid.rect(gp = gpar(col = "grey"))
grid.segments(c(1:4/5, rep(0, 3)), c(rep(0, 4), 1:3/4),
              c(1:4/5, rep(1, 3)), c(rep(1, 4), 1:3/4),
              gp = gpar(col = "grey"))
pushViewport(viewport(layout.pos.col = 2:3, layout.pos.row = 3))
grid.rect(gp = gpar(lwd = 3))
popViewport(2)
@
\begin{figure}[tbp]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-vplayout}
}
\end{center}
\caption{\label{figure:vplayout}
        A viewport positioned using a layout.}
\end{figure}

Layouts introduce a special unit type called \code{"null"}. These
units may be used within layouts to define relative column widths or
row heights. The following, more complex, example specifies a layout
resembling a standard plot arrangement: bottom and left margins three
lines of text wide, top and right margins 1 cm wide, and two rows and
columns within these margins where the bottom row is twice the height
of the top row (see Figure \ref{figure:vplayoutcomplex}).

<<layoutcomplex, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.show.layout(grid.layout(4, 4, widths = unit(c(3, 1, 1, 1),
                             c("lines", "null", "null", "cm")),
                             heights = c(1, 1, 2, 3),
                             c("cm", "null", "null", "lines")))
@
\begin{figure}[tbp]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-layoutcomplex}
}
\end{center}
\caption{\label{figure:vplayoutcomplex}
        A more complex layout.}
\end{figure}

\clearpage
\section{Producing Graphics Output}

\grid{} provides a standard set of graphical primitives: lines,
text, points, rectangles, polygons, and circles. Additionally, two
higher‑level components are available: x‑ and y‑axes. Table
\ref{table:primitives} lists the \grid{} functions that generate these
primitives.

\textbf{NOTE:} All of these graphical primitives may be used within
any graphical region and any coordinate system.

Prior to \R{} 2.3.0 a separate \code{grid.arrows()} function existed;
this has been superseded by an \code{arrow} argument to the
line‑drawing primitives (lines, segments, line‑to).

\begin{table}[h!]
\begin{center}
\begin{tabular}{l l} \hline
\code{grid.text} & Supports rotation via an \code{angle} argument. \\
\code{grid.rect} &  \\
\code{grid.circle} &  \\
\code{grid.polygon} &  \\
\code{grid.points} & Accepts a \code{pch} argument for plotting symbol type. \\
\code{grid.lines} &  \\
\code{grid.segments} &  \\
\code{grid.grill} & Convenience function for drawing grid lines \\
\code{grid.move.to} &  \\
\code{grid.line.to} &  \\
& \\
\code{grid.xaxis} & Can be drawn at top or bottom. \\
\code{grid.yaxis} & Can be drawn at left or right. \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:primitives}
         \grid{} graphical primitives.}
\end{table}

\subsection{Controlling the Appearance of Graphics Output}

\grid{} recognizes a fixed set of graphical parameters for modifying
the visual appearance of graphical output (see Table
\ref{table:gpars}).

\begin{table}[h!]
\begin{center}
\begin{tabular}{l l} \hline
\code{col} & Colour for lines, text, etc. \\
\code{fill} & Fill colour for rectangles, circles, polygons, etc. \\
\code{lwd} & Line width. \\
\code{lty} & Line type. \\
\code{fontsize} & Text size in points. \\
\code{fontface} &  Font face (bold, italic, etc.). \\
\code{fontfamily} & Font family. \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:gpars}
         \grid{} graphical parameters.}
\end{table}

Graphical parameter settings may be specified both for viewports and
for individual graphical objects. A setting attached to a viewport
applies to all graphical output within that viewport \emph{and} to all
viewports subsequently pushed onto the tree, \emph{unless} a graphical
object or a descendant viewport explicitly overrides that setting.

A description of graphical parameter settings is created with the
\code{gpar()} function; this description is associated with a viewport
or graphical object via the \code{gp} argument. The following code
demonstrates the effect of graphical parameter settings (see Figure
\ref{figure:gpar}).

<<gpar, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
pushViewport(viewport(gp = gpar(fill = "grey", fontface = "italic")))
grid.rect()
grid.rect(width = 0.8, height = 0.6, gp = gpar(fill = "white"))
grid.text(paste("This text and the inner rectangle",
                "have specified their own gpar settings", sep = "\n"),
          y = 0.75, gp = gpar(fontface = "plain"))
grid.text(paste("This text and the outer rectangle",
                "accept the gpar settings of the viewport", sep = "\n"),
          y = 0.25)
popViewport()
@
\begin{figure}[tbp]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-gpar}
}
\end{center}
\caption{\label{figure:gpar}
        The effect of different graphical parameter settings.}
\end{figure}

\clearpage
\section{Examples}

The remaining sections provide code examples illustrating the use of
\grid{}.

The first example constructs a simple scatterplot from first
principles. As with base graphics, creating a basic plot manually is
straightforward. The following code produces the equivalent of a
standard \code{plot(1:10)} (see Figure \ref{figure:simpleplot}).

<<simpleplot, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.rect(gp = gpar(lty = "dashed"))
x <- y <- 1:10
pushViewport(plotViewport(c(5.1, 4.1, 4.1, 2.1)))
pushViewport(dataViewport(x, y))
grid.rect()
grid.xaxis()
grid.yaxis()
grid.points(x, y)
grid.text("1:10", x = unit(-3, "lines"), rot = 90)
popViewport(2)
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-simpleplot}
}
\end{center}
\caption{\label{figure:simpleplot}
        The grid equivalent of \code{plot(1:10)}.}
\end{figure}

Now consider a more complex example: creating a barplot accompanied by
a legend (see Figure \ref{figure:barplot}). This task comprises two
main parts because \grid{} lacks a predefined barplot function; the
construction of the barplot itself will be instructive, so we begin
with that component.

The data to be plotted are as follows: we have four measures to
represent at four levels; the data are arranged in a matrix with
measures for each level in a column.

<<bpdata>>=
barData <- matrix(sample(1:4, 16, replace = TRUE), ncol = 4)
@
We will use colours to distinguish the measures.

<<barconstraint>>=
boxColours <- 1:4
@
We encapsulate the barplot creation within a function to facilitate
later combination with the legend.

<<bpfun>>=
bp <- function(barData) {
    nbars <- dim(barData)[2]
    nmeasures <- dim(barData)[1]
    barTotals <- rbind(rep(0, nbars), apply(barData, 2, cumsum))
    barYscale <- c(0, max(barTotals)*1.05)
    pushViewport(plotViewport(c(5, 4, 4, 1),
                              yscale = barYscale,
                              layout = grid.layout(1, nbars)))
    grid.rect()
    grid.yaxis()
    for (i in 1:nbars) {
        pushViewport(viewport(layout.pos.col = i, yscale = barYscale))
        grid.rect(x = rep(0.5, nmeasures),
                  y = unit(barTotals[1:nmeasures, i], "native"),
                  height = unit(diff(barTotals[,i]), "native"),
                  width = 0.8, just = "bottom", gp = gpar(fill = boxColours))
        popViewport()
    }
    popViewport()
}
@

Now we turn to the legend. We require some labels and impose the
constraint that the boxes in the legend be squares of side 0.5 inches.

<<legendlabels>>=
legLabels <- c("Group A", "Group B", "Group C", "Something Longer")
boxSize <- unit(0.5, "inches")
@

The following function draws the legend elements in a column, each
consisting of a coloured box with a label below.

<<legfun>>=
leg <- function(legLabels) {
    nlabels <- length(legLabels)
    pushViewport(viewport(layout = grid.layout(nlabels, 1)))
    for (i in 1:nlabels) {
        pushViewport(viewport(layout.pos.row = i))
        grid.rect(width = boxSize, height = boxSize, just = "bottom",
                  gp = gpar(fill = boxColours[i]))
        grid.text(legLabels[i], y = unit(0.5, "npc") - unit(1, "lines"))
        popViewport()
    }
    popViewport()
}
@

Having defined both components, we can arrange them together to form a
complete image. Note that we perform calculations to ensure sufficient
space is allocated for the legend, including a one‑line text margin on
the left and right. We also impose top and bottom margins on the
legend to match those of the plot.

<<barplot, results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
grid.rect(gp = gpar(lty = "dashed"))
legend.width <- max(unit(rep(1, length(legLabels)),
                         "strwidth", as.list(legLabels)) +
                    unit(2, "lines"),
                    unit(0.5, "inches") + unit(2, "lines"))
pushViewport(viewport(layout = grid.layout(1, 2,
                      widths = unit.c(unit(1,"null"), legend.width))))
pushViewport(viewport(layout.pos.col = 1))
bp(barData)
popViewport()
pushViewport(viewport(layout.pos.col = 2))
pushViewport(plotViewport(c(5, 0, 4, 0)))
leg(legLabels)
popViewport(3)
@
\begin{figure}[p]
\begin{center}
{
\includegraphics[width=3.5in, height=3.5in]{grid-barplot}
}
\end{center}
\caption{\label{figure:barplot}
        A barplot plus legend constructed from first principles using \grid{}.}
\end{figure}

\section{\grid{} and \lattice{}}

The \lattice{} package is built atop \grid{} and serves as a
sophisticated example of writing high‑level plotting functions with
\grid{}. Because \lattice{} output consists of \grid{} calls, it is
possible both to add \grid{} output to \lattice{} plots and to
incorporate \lattice{} output into \grid{} scenes.

The ``grid'' vignette in the \lattice{} package provides further
examples of this interoperability.

\bibliographystyle{plain}
\bibliography{grid}

\end{document}