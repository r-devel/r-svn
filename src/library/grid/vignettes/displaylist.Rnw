% File src/library/grid/vignettes/displaylist.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

\usepackage{Rd}

% \VignetteIndexEntry{Display Lists in grid}
% \VignettePackage{grid}
% \VignetteDepends{grDevices, graphics, stats}

\newcommand{\grid}{\pkg{grid}}
\newcommand{\gridBase}{\CRANpkg{gridBase}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{Display Lists in \grid{}}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(graphics) # for plot()
library(stats) # for runif()
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

A display list is a data structure that records a sequence of drawing
operations. It serves several purposes within the \R{} graphics system:
redrawing graphical output when a graphics window is resized,
transferring graphics output from one device to another, and supporting
the editing of graphical output (for example, via \code{grid.edit}).

When working with the \grid{} graphics system, two distinct display
lists may be involved. \R{}'s core graphics engine maintains its own
display list, while \grid{} maintains a separate display list at a
higher level. The graphics engine's display list is implemented in C
and records both base graphics and \grid{} graphics output. The
\grid{} display list is maintained at the \R{} level and exclusively
records \grid{} graphical objects (grobs) and their associated
operations.

Under standard operating conditions, the graphics engine's display
list handles redrawing when a window is resized and when copying
between devices. The \grid{} display list is employed when redrawing
is required during editing operations on \grid{} output.

Two principal limitations arise from this standard arrangement:

\begin{enumerate}
\item The graphics engine display list records only the final graphical
output; it does not preserve the computational steps that produced that
output. This deficiency particularly affects plots that perform
calculations based on the physical dimensions of the graphics device.
A prominent example is the \code{legend()} function, which computes
the layout of legend components. The consequence becomes apparent when
any plot employing \code{legend()} is resized; the legend arrangement
often becomes distorted.

\textbf{NOTE:} This issue is inherent to the graphics engine display
list and is not specific to \grid{}. Indeed, much of \grid{}'s design
mitigates this problem because constructs like \grid{} units are
declarative and are re-evaluated on each redraw. However, situations
exist where \grid{} output can be affected, particularly when the
\code{convertUnit()} function (or its variants) is employed (the help
file for \code{convertUnit()} provides an illustrative example).

This problem becomes especially relevant for \grid{} output when the
\gridBase{} package is used. That package performs numerous
calculations to align base and \grid{} graphics, but these
calculations are not captured by the graphics engine display list.
Consequently, resizing the device typically results in misaligned
output.

\item The \grid{} display list does not, by default, record base
graphics output\footnote{This statement is not entirely accurate; as
  will be demonstrated later, it is possible to incorporate base
  graphics output into the \grid{} display list.}. Therefore, if a
device contains a mixture of base and \grid{} graphics, editing
operations that trigger a redraw via the \grid{} display list will
not redraw the base graphics components. The following code provides a
simple demonstration:

<<guts1, eval=FALSE>>=
plot(1:10)
par(new = TRUE)
grid.rect(width = 0.5, height = 0.5, gp = gpar(lwd = 3), name = "gr")

<<ex1, echo=FALSE, fig=TRUE, width=4, height=3, include=FALSE>>=
<<guts1>>
grid.rect(width = 0.99, height = 0.99, gp = gpar(lty = "dashed"))
@
\includegraphics[width=4in, height=3in]{displaylist-ex1}

<<ex2, echo=FALSE, fig=TRUE, width=4, height=3, include=FALSE>>=
grid.rect(width = 0.5, height = 0.5, gp = gpar(col = "red", lwd = 3))
grid.rect(width = 0.99, height = 0.99, gp = gpar(lty = "dashed"))

<<eval=FALSE>>=
grid.edit("gr", gp = gpar(col = "red", lwd = 3))
@
\includegraphics[width=4in, height=3in]{displaylist-ex2}

After executing \code{grid.edit}, the rectangle has been redrawn with
the new graphical parameters, but the underlying base plot has not
been redrawn.
\end{enumerate}

\section*{Preserving calculations in the graphics engine display list\\
and incorporating base graphics into the \grid{} display list}

Both limitations described above can be addressed through the use of a
\code{drawDetails()} method within the \grid{} system. When a \grid{}
graphical object (grob) is drawn, its corresponding \code{drawDetails}
method is invoked. If computational steps are placed within such a
method, those calculations will be performed anew each time the grob
is drawn.

This approach makes it feasible, for example, to use
\code{convertUnit()} and obtain consistent results across device
resizes or copy operations\footnote{In the following examples, you
  should execute the code, resize the device to observe potential
  inconsistencies, then close the device before proceeding to the next
  example.}. The following code snippet demonstrates a case where
output becomes inconsistent upon device resizing. We specify a
rectangle width in inches, then (somewhat gratuitously) convert it to
normalized parent coordinates (\abbr{NPC}). Upon resizing, the \abbr{NPC}
coordinates will no longer correspond to the original one-inch
dimension.

<<results=hide>>=
grid.rect(width = convertWidth(unit(1, "inches"), "npc"))
@

The subsequent code illustrates that by encapsulating the calculations
within a \code{drawDetails} method, the output remains consistent
across device resizes and copy operations.

<<results=hide>>=
drawDetails.myrect <- function(x, recording) {
    gr <- rectGrob(width = convertWidth(unit(1, "inches"), "npc"))
    grid.draw(gr)
}
grid.draw(grob(cl = "myrect"))
@

The next example shows that a \code{drawDetails()} method can also be
utilized to embed base graphics output within the \grid{} display
list. This example employs the \gridBase{} package to combine base and
\grid{} graphics. We replicate the final example from the \gridBase{}
vignette, which places a series of base pie charts within \grid{}
viewports that are themselves positioned within a base plot. In this
instance, the necessary grobs can be created in the usual manner,
because their locations and sizes are not derived from specialized
calculations\footnote{The example includes a check for the presence of
  the \CRANpkg{gridBase} package to ensure the code remains executable
  on systems where the package is not installed.}.

<<results=hide>>=
x <- c(0.88, 1.00, 0.67, 0.34)
y <- c(0.87, 0.43, 0.04, 0.94)
z <- matrix(runif(4*2), ncol = 2)

maxpiesize <- unit(1, "inches")
totals <- apply(z, 1, sum)
sizemult <- totals/max(totals)

gs <- segmentsGrob(x0 = unit(c(rep(0, 4), x),
                             rep(c("npc", "native"), each = 4)),
                   x1 = unit(c(x, x), rep("native", 8)),
                   y0 = unit(c(y, rep(0, 4)),
                             rep(c("native", "npc"), each = 4)),
                   y1 = unit(c(y, y), rep("native", 8)),
                   gp = gpar(lty = "dashed", col = "grey"))
gr <- rectGrob(gp = gpar(col = "grey", fill = "white", lty = "dashed"))
@
The crucial aspect is that calls to \gridBase{} functions, along with
the calls to base graphics functions, are placed inside the
\code{drawDetails} method. Consequently, these operations are executed
every time the grob is drawn, ensuring that base graphics output is
reproduced during each redraw.

<<results=hide>>=
drawDetails.pieplot <- function(x, recording) {
    plot(x$x, x$y, xlim = c(-0.2, 1.2), ylim = c(-0.2, 1.2), type = "n")
    vps <- baseViewports()
    pushViewport(vps$inner, vps$figure, vps$plot, recording = FALSE)
    grid.draw(x$gs, recording = FALSE)
    for (i in 1:4) {
        pushViewport(viewport(x = unit(x$x[i], "native"),
                              y = unit(x$y[i], "native"),
                              width = x$sizemult[i]*x$maxpiesize,
                              height = x$sizemult[i]*x$maxpiesize),
                     recording = FALSE)
        grid.draw(x$gr, recording = FALSE)
        par(plt = gridPLT(), new = TRUE)
        pie(x$z[i, ], radius = 1, labels = rep("", 2))
        popViewport(recording = FALSE)
    }
    popViewport(3, recording = FALSE)
}
@
The ``pie plot'' is constructed by assembling the component grobs into
a composite grob of an appropriate custom class; the
\code{drawDetails} method is responsible for generating the actual
graphical output.

% Generate the figure, but do not include it in the document
% (to prevent contamination of par settings between code segments)

<<results=hide, fig=TRUE, width=6, height=6, include=FALSE>>=
if (suppressWarnings(require("gridBase", quietly = TRUE))) {
grid.draw(grob(x = x, y = y, z = z,
               maxpiesize = maxpiesize, sizemult = sizemult,
               gs = gs, gr = gr, cl = "pieplot"))
}
@

The output from this example can be safely resized; \grid{} manages
all redrawing, executing every action within the \code{drawDetails}
method during each redraw, including the reproduction of the base
graphics components.

As a final illustration, we harness the \grid{} display list solely to
achieve consistent rendering of base graphics output. The following
reproduces the last example from the \code{legend()} help page, but
produces output that remains correctly proportioned when the device is
resized.

% Generate the figure, but do not include it in the document
% (to prevent contamination of par settings between code segments)

<<results=hide, fig=TRUE, include=FALSE>>=
drawDetails.mylegend <- function(x, recording) {
    x <- 0:64/64
    y <- sin(3*pi*x)
    plot(x, y, type = "l", col = "blue",
         main = "points with bg & legend(*, pt.bg)")
    points(x, y, pch = 21, bg = "white")
    legend(.4,1, "sin(c x)", pch = 21, pt.bg = "white", lty = 1, col = "blue")
}
grid.draw(grob(cl = "mylegend"))
@
\end{document}