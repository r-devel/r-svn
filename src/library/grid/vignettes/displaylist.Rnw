%\VignetteEncoding{UTF-8}
% File src/library/grid/vignettes/displaylist.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001–2026 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}
\usepackage{Rd}

% \VignetteIndexEntry{Display Lists in grid}
% \VignettePackage{grid}
% \VignetteDepends{grDevices, graphics, stats}

\newcommand{\grid}{\pkg{grid}}
\newcommand{\gridBase}{\CRANpkg{gridBase}}
\newcommand{\lattice}{\CRANpkg{lattice}}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}


\title{Display Lists in \grid{}}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(graphics) # for plot()
library(stats)    # for runif()
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

A display list is a record of drawing operations. It is used to redraw
graphics output when a graphics window is resized, when output is copied
from one device to another, and when graphics output is edited (via
\code{grid.edit}).

There are two display lists relevant to \grid{}:
\begin{itemize}
\item The graphics engine display list, maintained at the C level,
records both base graphics and \grid{} output.
\item The \grid{} display list, maintained at the R level, records only
\grid{} output.
\end{itemize}

In standard usage, the graphics engine display list is used for redraws
when a window is resized or when copying between devices. The \grid{}
display list is used for redraws when editing \grid{} output.

\section*{Limitations of Standard Usage}

\begin{enumerate}
\item The graphics engine display list records only the drawing
operations, not the calculations that produced them. This affects plots
that depend on device dimensions. For example, resizing a device after
calling \code{legend()} may distort the legend layout. While \grid{}
units are declarative and often re‑evaluated correctly, functions such
as \code{convertUnit()} can still produce inconsistent results across
resizes.

A notable case arises when using the \gridBase{} package to align base
and \grid{} output. Because the alignment calculations are not stored in
the graphics engine display list, resizing the device can distort the
combined output. \gridBase{} is now considered a legacy package, but the
issue illustrates the importance of recalculating on redraw.

\item The \grid{} display list does not record base graphics output
(unless explicitly included). If both base and \grid{} output appear on
the same device, editing \grid{} output will not redraw the base
graphics. For example:

<<guts1, eval=FALSE>>=
plot(1:10)
par(new = TRUE)
grid.rect(width = 0.5, height = 0.5, gp = gpar(lwd = 3), name = "gr")
@
\end{enumerate}

\section*{Ensuring Consistency with \code{drawDetails()}}

Both problems can be avoided by using a \code{drawDetails()} method in
\grid{}. When a grob is drawn, its \code{drawDetails()} method is called.
Placing calculations inside this method ensures they are re‑evaluated on
every redraw.

For example, converting units inside \code{drawDetails()} guarantees
consistent results across device resizes:

<<results=hide>>=
drawDetails.myrect <- function(x, recording) {
    gr <- rectGrob(width = convertWidth(unit(1, "inches"), "npc"))
    grid.draw(gr)
}
grid.draw(grob(cl = "myrect"))
@

Similarly, \code{drawDetails()} can be used to incorporate base graphics
output into the \grid{} display list. The following example (adapted
from the \gridBase{} vignette) demonstrates combining base pie charts
with \grid{} viewports. Although \gridBase{} is largely historical, the
example illustrates how redraw consistency can be achieved:

<<results=hide>>=
drawDetails.pieplot <- function(x, recording) {
    plot(x$x, x$y, xlim = c(-0.2, 1.2), ylim = c(-0.2, 1.2), type = "n")
    vps <- baseViewports()
    pushViewport(vps$inner, vps$figure, vps$plot, recording = FALSE)
    grid.draw(x$gs, recording = FALSE)
    for (i in 1:4) {
        pushViewport(viewport(x = unit(x$x[i], "native"),
                              y = unit(x$y[i], "native"),
                              width = x$sizemult[i]*x$maxpiesize,
                              height = x$sizemult[i]*x$maxpiesize),
                     recording = FALSE)
        grid.draw(x$gr, recording = FALSE)
        par(plt = gridPLT(), new = TRUE)
        pie(x$z[i, ], radius = 1, labels = rep("", 2))
        popViewport(recording = FALSE)
    }
    popViewport(3, recording = FALSE)
}
@

Finally, \code{drawDetails()} can be used to stabilize base graphics
output such as legends. The following example reproduces the last
example from \code{legend()}, but ensures correct redraw behaviour:

<<results=hide>>=
drawDetails.mylegend <- function(x, recording) {
    x <- 0:64/64
    y <- sin(3*pi*x)
    plot(x, y, type = "l", col = "blue",
         main = "points with bg & legend(*, pt.bg)")
    points(x, y, pch = 21, bg = "white")
    legend(.4, 1, "sin(c x)", pch = 21, pt.bg = "white",
           lty = 1, col = "blue")
}
grid.draw(grob(cl = "mylegend"))
@

\end{document}
