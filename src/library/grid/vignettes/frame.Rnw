% File src/library/grid/vignettes/frame.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001-13 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}
%\VignetteIndexEntry{Frames and packing grobs}
%\VignettePackage{grid}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\grid}{\pkg{grid}}
\newcommand{\R}{{\sffamily R}}
\newcommand{\I}[1]{#1}
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{A GUI-Builder Approach to \grid{} Graphics}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(stats) # for runif
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

The \grid{} graphics system provides extensive facilities for
positioning, sizing, and arranging graphical components on a device and
relative to one another. However, much of this functionality operates
under one of two paradigms: either the parent graphical object dictates
both the location and size of its children (as in layouts), or the
child object specifies both its own location and size.

Certain arrangements are more naturally expressed by an intermediate
model where the parent controls placement while the child determines
its dimensions. This model is characteristic of many graphical user
interface (GUI) builders, which allow the user to create a parent
\emph{frame} and then \emph{pack} widgets into that frame. The frame
handles positioning and arrangement based on directional hints (such as
``place this widget at the bottom''), while each widget specifies its
preferred size.

This document describes an initial implementation of such an interface
for arranging \grid{} graphical objects (grobs).

\section*{The \code{"frame"} grob}
A \code{"frame"} graphical object can be created using the
\code{frameGrob()} function. The result must be assigned to a variable
to allow subsequent packing of grobs into it.

<<results=hide>>=
gf <- frameGrob()
@

\section*{The \code{packGrob()} function}
Once a frame is created, other graphical objects can be packed into it
using the \code{packGrob()} function. This function offers a
comprehensive interface supporting various packing strategies. The
required arguments are:
\begin{description}
\item[\code{frame}] a \code{"frame"} object created by
  \code{frameGrob()}.
\item[\code{grob}] the grob to be packed into the frame.
\end{description}
Additional arguments specify the location of the grob within the frame
and optionally control the space it occupies. Conceptually, a frame
behaves like a layout; grobs can be added to existing rows and columns,
or appended in new rows and/or columns. When a grob is added to an
existing row, the row height becomes the maximum of the new height and
the previous height. If the row is new, it simply adopts the specified
height. Analogous rules apply to column widths.
\begin{description}
\item[\code{col}] the column in which to place the grob. This may be
  one greater than the current number of columns, in which case a new
  column is appended.
\item[\code{row}] analogous to \code{col}, but for rows.
\item[\code{col.after}] indicates that the grob should be placed in a
  new column inserted between columns \code{col.after} and
  \code{col.after + 1}.
\item[\code{col.before}] indicates that the grob should be placed in a
  new column inserted between columns \code{col.before} and
  \code{col.before + 1}.
\item[\code{row.after} and \code{row.before}] operate similarly for rows.
\item[\code{side}] specifies which side of the frame to append the new
  grob. Valid values are \code{"left"}, \code{"right"},
  \code{"bottom"}, and \code{"top"}.
\item[\code{width}] the width of the column into which the grob is
  being packed. If omitted, the grob supplies its own width.
\item[\code{height}] analogous to \code{width}, but for rows.
\end{description}
The default behavior can be modified. For example, a grob can be added
to a row while forcing that row to a specific height by setting
\code{force.height=TRUE} (similarly for column widths via
\code{force.width}). It is also possible to pack a grob across multiple
rows or columns simultaneously (although in such cases the heights or
widths of those rows/columns cannot be individually controlled).

The function returns the modified frame, so the result must be assigned
to a variable.

<<results=hide>>=
gf <- packGrob(gf, textGrob("Hello frame!"))
@

\section*{\code{"grobwidth"} and \code{"grobheight"} units}

A \code{"frame"} object permits a grob to specify its size through the
use of \code{"grobwidth"} and \code{"grobheight"} units. These units
are not restricted to frames and may be employed in any \grid{}
context; their general usage is described here.

Consider a simple example in which a rectangle is to be drawn around a
text label. The dimensions of the text can be obtained from the
\code{"text"} grob as follows:

<<frame1, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
st <- grid.text("some text")
grid.rect(width = unit(1, "grobwidth", st),
          height = unit(1, "grobheight", st))
@
\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame1}
\end{center}

An equivalent result could be achieved using the simpler
\code{"strwidth"} and \code{"strheight"} units, but
\code{"grobwidth"} and \code{"grobheight"} offer greater flexibility.
A key advantage is that they can obtain the size of any graphical
object, not just text. Furthermore, a grob can be referenced by name
rather than by value, creating a \emph{dynamic} unit that updates when
the referenced grob changes. The following demonstrates a dynamic
version of the previous example.

<<frame1, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
grid.text("some text", name = "st")
grid.rect(width = unit(1, "grobwidth", "st"),
          height = unit(1, "grobheight", "st"))
@

Now observe the effect of modifying the text grob named \code{"st"}:

<<results=hide, eval=FALSE>>=
grid.edit("st", gp = gpar(fontsize = 20))

<<frame2, echo=FALSE, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
my.text <- textGrob("some text")
my.text <- editGrob(my.text, gp = gpar(fontsize = 20))
my.rect <- rectGrob(width = unit(1, "grobwidth", my.text),
                    height = unit(1, "grobheight", my.text))
grid.draw(my.text)
grid.draw(my.rect)
@
\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame2}
\end{center}

Similarly, the text content itself can be altered:

<<results=hide, eval=FALSE>>=
grid.edit("st", label="some different text")

<<frame3, echo=FALSE, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
my.text <- textGrob("some text")
my.text <- editGrob(my.text, gp = gpar(fontsize = 20))
my.text <- editGrob(my.text, label = "some different text")
my.rect <- rectGrob(width = unit(1, "grobwidth", my.text),
                    height = unit(1, "grobheight", my.text))
grid.draw(my.text)
grid.draw(my.rect)
@
\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame3}
\end{center}

\section*{The \code{widthDetails} and \code{heightDetails} generic functions}

The computation of \code{"grobwidth"} and \code{"grobheight"} units
involves some complexity, but most of the process is automated. The
fundamental step is that a grob must provide a \code{"unit"} object
representing its width or height. The complexity arises because this
unit must be evaluated in the appropriate graphical context;
specifically, if the grob has a non-\code{NULL} \code{vp} (viewport)
argument, those viewports must be pushed so that the grob's size
reflects what it would be when actually drawn. This is accomplished by
invoking the \code{preDrawDetails()} method for the grob, and in most
cases the default behavior suffices. A critical practice is to avoid
placing viewport operations within a \code{drawDetails()} method;
such operations should reside in a \code{preDrawDetails()} method.

The primary developer responsibility is usually to provide functions
that return the appropriate \code{"unit"} objects. These functions are
\code{widthDetails} and \code{heightDetails} methods.

The default methods return \code{unit(1, "null")}, so a custom grob
will have that size unless explicit methods are provided.

Classic examples are the methods for \code{"text"} grobs; these return
\code{unit(1, "mystrwidth", <text grob label>)} and
\code{unit(1, "mystrheight", <text grob label>)}, respectively.

Equally important are the methods for \code{"frame"} grobs. These
return the sum of the widths (or heights) of the columns (or rows) of
the layout constructed by packing grobs into the frame. Consequently,
when a \code{"frame"} grob is packed inside another \code{"frame"}
grob, the parent automatically allocates sufficient space for the
child.

Another useful pair of examples are the methods for \code{"rect"}
grobs. These methods utilize the \code{absolute.size} function. When a
grob is queried for its size, it is sensible to respond with its width
and height if those dimensions are expressed in ``absolute'' units
(e.g., \code{"inches"}, \code{"cm"}, \code{"lines"}; i.e., the grob
knows its exact size). Conversely, it is not meaningful to return the
grob's width and height if those are expressed in ``relative'' units
(e.g., \code{"npc"} or \code{"native"}; i.e., the grob's size depends
on its parent's dimensions). The \code{absolute.size} function leaves
absolute units unchanged but converts relative units to \code{"null"}
units (indicating to the parent, ``you decide my size''). Thus, one
can return something like \code{absolute.size(width(<grob>))} to always
provide a reasonable answer.

\section*{Examples}
The original motivation for this GUI-builder approach was to
facilitate the creation of a general-purpose legend grob.

A legend typically comprises data symbols paired with textual
descriptions. To achieve generality, it is desirable to permit, for
instance, multiple lines of text per symbol. Rather than pre‑analyzing
the supplied text to determine the legend layout, it is preferable to
specify the legend's composition and allow it to self‑arrange. The
code below defines such a legend grob using the new \code{"frame"}
grob and \code{packGrob()} function. Notable aspects include:

\begin{itemize}
\item The use of \code{border} arguments to create spacing around
  legend components.
\item The size of the data‑symbol component is explicitly specified,
  whereas text component sizes are derived from the \code{"text"}
  grobs.
\item Row heights in the legend become the maximum of
  $\code{vgap} + \code{unit(1, "lines")}$ and $\code{vgap} +
  \code{unit(1, "grobheight", <text grob>)}$.
\item Two functions are provided: one to generate the grob, another to
  produce the output.
\end{itemize}

<<>>=
legendGrob <- function(pch, labels, frame = TRUE,
                        hgap = unit(1, "lines"), vgap = unit(1, "lines"),
                        default.units = "lines",
                        vp = NULL) {
  nkeys <- length(labels)
  gf <- frameGrob(vp = vp)
  for (i in 1:nkeys) {
    if (i == 1) {
        symbol.border <- unit.c(vgap, hgap, vgap, hgap)
        text.border <- unit.c(vgap, unit(0, "npc"), vgap,
            hgap)
    } else {
        symbol.border <- unit.c(vgap, hgap, unit(0, "npc"), hgap)
        text.border <- unit.c(vgap, unit(0, "npc"), unit(0, "npc"), hgap)
    }
    gf <- packGrob(gf, pointsGrob(0.5, 0.5, pch = pch[i]),
                   col = 1, row = i, border = symbol.border,
                   width = unit(1, "lines"),
                   height = unit(1, "lines"), force.width = TRUE)
    gf <- packGrob(gf, textGrob(labels[i], x = 0, y = 0.5,
                                just = c("left", "centre")),
                   col = 2, row = i, border = text.border)
  }
  gf
}

grid.legend <- function(pch, labels, frame = TRUE,
                        hgap = unit(1, "lines"), vgap = unit(1, "lines"),
                        default.units = "lines", draw = TRUE,
                        vp = NULL) {
  gf <- legendGrob(pch, labels, frame, hgap, vgap, default.units, vp)
  if (draw) grid.draw(gf)
  gf
}
@

The following code demonstrates the procedural use of
\code{grid.legend()}; the resulting output appears below the code.

<<legend, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
grid.legend(1:3, c("one line", "two\nlines", "three\nlines\nof text"))

@
\begin{center}
\includegraphics[height=2in, width=4in]{frame-legend}
\end{center}

The legend example might appear manageable without frames and packing,
but the next example illustrates the utility of this approach.

Suppose one wishes to arrange a legend adjacent to a plot. This
requires allocating sufficient space for the legend and filling the
remaining area with the plot. Determining the required space for the
legend is neither trivial nor easily generalized. Ideally, we should
need minimal prior knowledge about the legend.

The GUI‑builder approach makes this task remarkably straightforward.
The code below illustrates the construction of such a scene; the
resulting output is shown beneath.

Noteworthy points include:

\begin{itemize}
\item No knowledge of the legend's internal construction is required;
  it could be any grob.
\item The legend's height is set to \code{unit(1, "null")}, causing it
  to occupy the full height of the plot. Without this specification,
  the plot would be constrained to the legend's height (due to the
  interaction of \code{"null"} units with other units).
\item The legend's width is automatically computed from its contents
  because the legend is a \code{"frame"} grob.
\item The dimensions of the ``plot'' default to \code{unit(1, "null")}
  because \code{"collection"} grobs lack width and height methods;
  consequently, the plot expands to fill the space remaining after the
  legend is accommodated.
\end{itemize}

<<plot, echo=FALSE, include=FALSE, fig=TRUE, results=hide>>=
top.vp <- viewport(width = 0.8, height = 0.8)
pushViewport(top.vp)
x <- runif(10)
y1 <- runif(10)
y2 <- runif(10)
pch <- 1:3
labels <- c("Girls", "Boys", "Other")
gf <- frameGrob()
plt <- gTree(children = gList(rectGrob(),
                              pointsGrob(x, y1, pch = 1),
                              pointsGrob(x, y2, pch = 2),
                              xaxisGrob(),
                              yaxisGrob()))
gf <- packGrob(gf, plt)
gf <- packGrob(gf, legendGrob(pch, labels),
               height = unit(1, "null"), side = "right")
grid.rect(gp = gpar(col = "grey"))
grid.draw(gf)
popViewport()
grid.rect(gp = gpar(lty = "dashed"), width = .99, height = .99)
@
\begin{center}
\includegraphics{frame-plot}
\end{center}

\section*{Notes}
\begin{enumerate}
\item Corresponding \code{grid.frame()} and \code{grid.pack()}
  functions exist, but these are primarily useful for observing
  incremental changes to the frame as each packing operation occurs.

\item The frame‑and‑packing interface is easier to use but (in nearly
  all cases) less efficient than manually specifying the arrangement.
  Consequently, there is a penalty in terms of memory usage (generally
  negligible) and speed (noticeably slower). A sensible workflow might
  involve interactive construction of an image using the simpler
  arguments (which will be slower) followed by optimization for speed
  by exploring more advanced arguments.

  One approach to improve performance is to define the layout when the
  frame is initially created and then employ the \code{placeGrob()}
  function to insert grobs into predefined rows and columns.

  The observed speed penalty is largely attributable to the time
  required to generate the (sometimes highly) complex unit objects that
  express the heights and widths of the frame's rows and columns.
  Future development efforts may focus on accelerating unit object
  creation.
\end{enumerate}
\end{document}

