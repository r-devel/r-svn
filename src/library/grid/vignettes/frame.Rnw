%\VignetteEncoding{UTF-8}
% File src/library/grid/vignettes/frame.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2001–2026 Paul Murrell and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}
%\VignetteIndexEntry{Frames and packing grobs}
%\VignettePackage{grid}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\grid}{\pkg{grid}}
\newcommand{\R}{{\sffamily R}}
\newcommand{\I}[1]{#1}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{A GUI-Builder Approach to \grid{} Graphics}
\author{Paul Murrell}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(grDevices)
library(stats)   # for runif
library(grid)
ps.options(pointsize = 12)
options(width = 60)
@

The \grid{} package provides extensive support for locating, sizing, and arranging
graphical components on a device and relative to each other. Most of this support
relies on either the parent object dictating both location and size (layouts) or
the child dictating both location and size.

Some arrangements are more conveniently handled by having the parent dictate
location while allowing the child to dictate size. This is common in GUI builders,
which arrange graphical components (widgets) by placing them into a parent
\emph{frame}. The frame controls positioning with hints such as “place this widget
at the bottom of the frame,” while the children determine their preferred size.

This vignette describes an interface for arranging \grid{} graphical objects using
a frame‑and‑packing approach.

\section*{The \code{"frame"} grob}
A \code{"frame"} graphical object can be created using the function
\code{frameGrob()}. The result must be assigned to a variable in order to pack
grobs into it.

<<results=hide>>=
gf <- frameGrob()
@

\section*{The \code{packGrob()} function}
Once a frame has been created, other graphical objects can be packed into it using
the \code{packGrob()} function. This function provides a flexible interface for
specifying how grobs are arranged. The required arguments are:

\begin{description}
\item[\code{frame}] A \code{"frame"} object created by \code{frameGrob()}.
\item[\code{grob}] The grob to pack into the frame.
\end{description}

Additional arguments control placement and sizing. The frame acts like a layout:
grobs can be added to existing rows and columns or appended to new ones. If a grob
is added to an existing row, the row height becomes the maximum of the new and
previous heights. New rows or columns adopt the specified dimensions. Similar rules
apply for column widths.

\begin{description}
\item[\code{col}] Column index for the grob. May be one greater than the current
number of columns (to add a new column).
\item[\code{row}] Row index for the grob.
\item[\code{col.after}] Insert a new column between \code{col.after} and
\code{col.after + 1}.
\item[\code{col.before}] Insert a new column between \code{col.before} and
\code{col.before + 1}.
\item[\code{row.after}, \code{row.before}] Analogous to column insertion.
\item[\code{side}] Append the grob to a specified side: \code{"left"},
\code{"right"}, \code{"bottom"}, or \code{"top"}.
\item[\code{width}] Width of the column. If omitted, the grob supplies its width.
\item[\code{height}] Height of the row. If omitted, the grob supplies its height.
\end{description}

Default behaviour can be modified. For example, setting \code{force.height=TRUE}
forces a row to adopt the specified height regardless of grob size. Grobs can also
span multiple rows or columns, though their dimensions cannot simultaneously alter
all spanned rows or columns.

The function returns the modified frame, so the result must be reassigned:

<<results=hide>>=
gf <- packGrob(gf, textGrob("Hello frame!"))
@

\section*{\code{"grobwidth"} and \code{"grobheight"} units}
A \code{"frame"} object allows grobs to specify their size using
\code{"grobwidth"} and \code{"grobheight"} units. These units can also be used
outside frames.

For example, to draw a rectangle around a piece of text, the size of the text grob
can be queried directly:

<<frame1, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
st <- grid.text("some text")
grid.rect(width = unit(1, "grobwidth", st),
          height = unit(1, "grobheight", st))
@
\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame1}
\end{center}
@
You could achieve similar results with simple \code{"strwidth"} and
\code{"strheight"} units, but \code{"grobwidth"} and \code{"grobheight"}
provide significantly more flexibility. The main advantage is that they
can measure the size of objects beyond text grobs. Additionally, these
units can be made dynamic by referencing a grob by name rather than
passing the grob object directly. In this case, changes to the grob
automatically affect the unit.

For example, here is a dynamic version of the earlier rectangle‑around‑text
example:

<<frame1, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
grid.text("some text", name = "st")
grid.rect(width = unit(1, "grobwidth", "st"),
          height = unit(1, "grobheight", "st"))
@

If the text grob named \code{"st"} is modified, the rectangle updates
accordingly:

<<results=hide, eval=FALSE>>=
grid.edit("st", gp = gpar(fontsize = 20))
@

\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame2}
\end{center}

Similarly, changing the text label itself updates the rectangle size:

<<results=hide, eval=FALSE>>=
grid.edit("st", label = "some different text")
@

\begin{center}
\includegraphics[height=1in, width=2in]{frame-frame3}
\end{center}

\section*{The \code{widthDetails} and \code{heightDetails} generic functions}

The calculation of \code{"grobwidth"} and \code{"grobheight"} units is
automated in most cases, but requires careful handling of context. A grob
typically provides a standard \code{"unit"} object to express its width or
height. However, if the grob has a non‑\code{NULL} \code{vp} argument, the
associated viewports must be pushed so that the grob’s size is evaluated
as it would be when drawn. This is handled by the \code{preDrawDetails()}
function, which ensures correct evaluation. Importantly, viewport
operations should be placed in \code{preDrawDetails()} rather than
\code{drawDetails()} methods.

In practice, developers usually only need to implement methods that
return the appropriate \code{"unit"} objects: \code{widthDetails} and
\code{heightDetails}.

- The default methods return \code{unit(1, "null")}, meaning grobs will
  have this size unless custom methods are defined.
- For \code{"text"} grobs, methods return
  \code{unit(1, "mystrwidth", <label>)} and
  \code{unit(1, "mystrheight", <label>)}.
- For \code{"frame"} grobs, methods return the sum of the widths or
  heights of the layout’s columns or rows. This ensures that when a
  \code{"frame"} grob is packed inside another frame, the parent
  automatically allocates sufficient space.
- For \code{"rect"} grobs, methods use the \code{absolute.size()}
  function. Grobs with absolute units (e.g., \code{"inches"}, \code{"cm"},
  \code{"lines"}) can report their exact size. Grobs with relative units
  (e.g., \code{"npc"}, \code{"native"}) cannot determine their size until
  the parent’s dimensions are known. In these cases,
  \code{absolute.size()} converts relative units to \code{"null"}, allowing
  the parent to decide the size. For example:
  \code{absolute.size(width(<grob>))} ensures a sensible response in all
  contexts.


\section*{Examples}
The motivating example for this GUI‑builder approach was to produce a
general‑purpose legend grob.

A legend consists of data symbols and associated textual descriptions.
To be flexible, it should allow features such as multiple lines of text
per symbol. Rather than requiring manual arrangement based on the text
supplied, it is preferable to specify the composition of the legend and
let the system determine the layout. The following code defines such a
legend grob using the \code{"frame"} grob and \code{packGrob()}:

\begin{itemize}
\item Borders are used to create spacing around legend components.
\item The size of the symbol component is specified explicitly, while
text components derive their size from the \code{"text"} grobs.
\item Row heights are determined as the maximum of
\code{vgap + unit(1, "lines")} and
\code{vgap + unit(1, "grobheight", <text grob>)}.
\item Two functions are provided: one to generate the grob and one to
produce output.
\end{itemize}

<<>>=
legendGrob <- function(pch, labels, frame = TRUE,
                        hgap = unit(1, "lines"), vgap = unit(1, "lines"),
                        default.units = "lines",
                        vp = NULL) {
  nkeys <- length(labels)
  gf <- frameGrob(vp = vp)
  for (i in 1:nkeys) {
    if (i == 1) {
        symbol.border <- unit.c(vgap, hgap, vgap, hgap)
        text.border <- unit.c(vgap, unit(0, "npc"), vgap, hgap)
    } else {
        symbol.border <- unit.c(vgap, hgap, unit(0, "npc"), hgap)
        text.border <- unit.c(vgap, unit(0, "npc"), unit(0, "npc"), hgap)
    }
    gf <- packGrob(gf, pointsGrob(0.5, 0.5, pch = pch[i]),
                   col = 1, row = i, border = symbol.border,
                   width = unit(1, "lines"),
                   height = unit(1, "lines"), force.width = TRUE)
    gf <- packGrob(gf, textGrob(labels[i], x = 0, y = 0.5,
                                just = c("left", "centre")),
                   col = 2, row = i, border = text.border)
  }
  gf
}

grid.legend <- function(pch, labels, frame = TRUE,
                        hgap = unit(1, "lines"), vgap = unit(1, "lines"),
                        default.units = "lines", draw = TRUE,
                        vp = NULL) {
  gf <- legendGrob(pch, labels, frame, hgap, vgap, default.units, vp)
  if (draw) grid.draw(gf)
  gf
}
@

The \code{grid.legend()} function can be used procedurally:

<<legend, include=FALSE, width=4, height=2, fig=TRUE, results=hide>>=
grid.legend(1:3, c("one line", "two\nlines", "three\nlines\nof text"))
@
\begin{center}
\includegraphics[height=2in, width=4in]{frame-legend}
\end{center}

Although constructing a legend manually is possible, frames and packing
simplify more complex layouts. For example, arranging a legend beside a
plot requires allocating space for the legend and filling the remainder
with the plot. Determining legend size manually is non‑trivial, but the
GUI‑builder approach makes this straightforward:

\begin{itemize}
\item The legend can be any grob; its internal construction is irrelevant.
\item Setting the legend height to \code{unit(1, "null")} ensures it
occupies the full plot height. Without this, the plot would be forced to
match the legend height.
\item The legend width is calculated automatically because it is a
\code{"frame"} grob.
\item The plot dimensions default to \code{unit(1, "null")} since
\code{"collection"} grobs lack width/height methods, allowing the plot
to fill remaining space.
\end{itemize}

<<plot, echo=FALSE, include=FALSE, fig=TRUE, results=hide>>=
top.vp <- viewport(width = 0.8, height = 0.8)
pushViewport(top.vp)
x <- runif(10)
y1 <- runif(10)
y2 <- runif(10)
pch <- 1:3
labels <- c("Girls", "Boys", "Other")
gf <- frameGrob()
plt <- gTree(children = gList(rectGrob(),
                              pointsGrob(x, y1, pch = 1),
                              pointsGrob(x, y2, pch = 2),
                              xaxisGrob(),
                              yaxisGrob()))
gf <- packGrob(gf, plt)
gf <- packGrob(gf, legendGrob(pch, labels),
               height = unit(1, "null"), side = "right")
grid.rect(gp = gpar(col = "grey"))
grid.draw(gf)
popViewport()
grid.rect(gp = gpar(lty = "dashed"), width = .99, height = .99)
@

\begin{center}
\includegraphics{frame-plot}
\end{center}

\section*{Notes}
\begin{enumerate}
\item \code{grid.frame()} and \code{grid.pack()} equivalents exist, but
are mainly useful for observing incremental changes during packing.
\item The frame‑and‑packing approach is easier to use but less efficient
than manual layout specification. It incurs minor memory overhead and
noticeable speed penalties.
\item A practical workflow is to build an image interactively using
simple arguments, then optimize performance by exploring advanced
arguments.
\item Performance can be improved by specifying the layout when the
frame is created and using \code{placeGrob()} to insert grobs into
existing rows and columns.
\item Speed penalties are largely due to the complexity of unit objects
that describe row and column dimensions. Future work aims to improve the
efficiency of unit object creation.
\end{enumerate}

\end{document}


