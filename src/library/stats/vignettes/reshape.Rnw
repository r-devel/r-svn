% File src/library/stats/vignettes/reshape.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2021-2023 The R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

\usepackage{Rd}

\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}

\title{Using the reshape function}
\author{The R Core Team}
% \VignetteIndexEntry{Using the reshape function}
% \VignettePackage{stats}

\begin{document}
\maketitle

<<echo=FALSE, results=hide>>=
library(stats)
options(width = 80, continue = "  ",
        try.outFile = stdout())
@


\section{Introduction}

The \code{reshape()} function provides facilities for converting data
between the \sQuote{wide} and \sQuote{long} structural formats.  In
the wide format, repeated measurements corresponding to the same
underlying variable are stored in separate columns within a single
row.  Conversely, in the long format, repeated measurements appear as
separate rows, with an additional column or columns to distinguish
between the different measurement occasions.

While \code{reshape()} can be employed in various data restructuring
contexts, its design and terminology are particularly oriented towards
handling longitudinal or repeated-measures data.  The function's
arguments are named and documented with this application in mind; see
the help documentation (\code{help(reshape)}) for comprehensive
background and detailed usage information.

For illustrative purposes throughout this vignette, we simulate data
from a hypothetical longitudinal study in which individuals are
assessed at two distinct time points.  Two measurements are considered
time-varying: height and weight.  One measurement, sex, is treated as
time-constant.

\section{Conversion from wide to long format}

We begin by generating a dataset in the wide format.  Each individual
occupies one row, with separate columns for time-constant variables
and for each instance of the time-varying variables.  Given two time
points (before and after), each time-varying variable yields two
columns.

<<>>=
set.seed(12345)
n <- 5
d1 <- data.frame(sex = sample(c("M", "F"), n, replace = TRUE),
                 ht.before = round(rnorm(n, 165, 6), 1),
                 ht.after = round(rnorm(n, 165, 6), 1),
                 wt.before = round(rnorm(n, 80, 6)),
                 wt.after = round(rnorm(n, 80, 6)))
d1
@

Suppose we intend to transform this dataset into a long format
representation, wherein each individual contributes two rows, and each
variable (whether time-constant or time-varying) occupies a single
column.  Such a representation necessitates two additional variables
to differentiate the multiple rows stemming from a single wide-format
row: an identifier variable (id) and a time indicator variable.  These
variables are generated automatically during the conversion from wide
to long format.

However, we must specify which columns in the wide format correspond
to different measurements of the same underlying time-varying
variable.  This specification is most straightforward when only one
time-varying variable exists.  Although our example contains two such
variables (height and weight), let us initially consider only height
as time-varying.  The relevant columns are specified via the
\code{varying} argument.  Under this specification, the two weight
variables will be interpreted as distinct time-constant variables,
analogous to sex.

%% specify only ht variables as time-variables (wt variables assumed
%% to be separate time constant variables)

<<>>=
reshape(d1, direction = "long",
        varying = c("ht.before", "ht.after"))
@

Specifying the variables by column index yields an identical result.

<<>>=
reshape(d1, direction = "long",
        varying = c(2, 3))
@

Note that the name of the combined variable in the long format, as
well as the values assigned to the time variable, are automatically
inferred because the column names adhere to a \dQuote{regular}
format.  Consider an alternative naming scheme:

<<>>=
n <- 5
d2 <- data.frame(sex = sample(c("M", "F"), n, replace = TRUE),
                 ht_before = round(rnorm(n, 165, 6), 1),
                 ht_after = round(rnorm(n, 165, 6), 1),
                 wt_before = round(rnorm(n, 80, 6)),
                 wt_after = round(rnorm(n, 80, 6)))
@

Attempting to adapt the previous call produces an error:

%% Error: Fails to guess

<<>>=
try(
reshape(d2, direction = "long",
        varying = c("wt_before", "wt_after")),
)
@

This situation is easily remedied because the names remain regularly
structured, merely employing an underscore separator different from the
default period expected by \code{reshape()}.

<<>>=
reshape(d2, direction = "long",
        varying = c("wt_before", "wt_after"), sep = "_")
@

A more general solution involves explicitly specifying the name for
the new combined column via the \code{v.names} argument.

<<>>=
reshape(d2, direction = "long",
        varying = c("wt_before", "wt_after"),
        v.names = "weight") 
@

We may also explicitly control the names and values of the id and time
variables.

<<>>=
reshape(d2, direction = "long",
        varying = c("wt_before", "wt_after"),
        v.names = "weight", 
        timevar = "when", times = c("pre", "post"),
        idvar = "subject", ids = letters[1:n])
@

It is important to note that the \code{times} argument is disregarded
when automatic name guessing is active, i.e., when \code{v.names} is
not explicitly supplied.

<<>>=
reshape(d2, direction = "long",
        varying = c("wt_before", "wt_after"), sep = "_",
        ## v.names = "wt", # without this, 'times' is unused 
        timevar = "when", times = c("pre", "post"))
@

The examples thus far have involved only a single time-varying
variable, whereas our dataset contains two.  Specifying multiple
time-varying variables depends on whether the column names follow a
guessable pattern.

\subsection{Explicit specification of variable names}

The general approach requires explicit specification of both
\code{varying} and \code{v.names}.  The \code{v.names} argument should
be a character vector providing the names for the time-varying
variables in the resulting long format.  Correspondingly,
\code{varying} should be a list, where each component is a vector of
the wide-format column names for one time-varying variable, or a
matrix, where each row contains the wide-format column names for one
time-varying variable.

<<>>=
reshape(d2, direction = "long",
        varying = list(c("ht_before", "ht_after"),
                       c("wt_before", "wt_after")), # list form
        v.names = c("height", "weight"),
        times = c("pre", "post"))

reshape(d2, direction = "long",
        varying = rbind(c("ht_before", "ht_after"),
                        c("wt_before", "wt_after")), # matrix form
        v.names = c("height", "weight"))
@

In the second example above, the \code{times} argument was omitted,
causing sequential integer times to be used as defaults.  The
\code{v.names} argument may also be omitted, but the resulting default
names are generally not meaningful.

As before, the names and values of the time and identifier variables
can be controlled explicitly, provided \code{v.names} is specified.

<<>>=
reshape(d2, direction = "long",
        varying = rbind(c("ht_before", "ht_after"),
                        c("wt_before", "wt_after")),
        v.names = c("height", "weight"),
        timevar = "when",
        times = c("pre", "post"),
        idvar = "subject",
        ids = letters[1:n])
@

\subsection{Variable names in a guessable format}

Even when variable names follow a guessable pattern,
\code{reshape()} refrains from automatic guessing if multiple
time-varying variables are supplied as a list or matrix.  However,
when all time-varying columns share a consistently applied naming
convention, automatic guessing can still be leveraged by providing the
\code{varying} argument as an atomic vector (of names or indices)
containing all columns belonging to time-varying variables.

<<>>=
reshape(d2, direction = "long",
        varying = c("ht_before", "ht_after",
                    "wt_before", "wt_after"), sep = "_")
@

The atomic vector form of \code{varying} can be combined with an
explicit (non-guessed) \code{v.names} specification, but this requires
careful attention to the ordering of names within \code{varying}.  The
following ordering yields incorrect results:

<<>>=
reshape(d2, direction = "long",
        varying = c("ht_before", "ht_after",
                    "wt_before", "wt_after"),
        v.names = c("height", "weight"))
@

The correct ordering requires that all columns corresponding to the
same time point be contiguous; this corresponds to the column-major
ordering implicit in the matrix representation discussed earlier.
Unless \code{v.names} is omitted, it is generally advisable to avoid
the atomic vector form of \code{varying}.

<<echo=FALSE,eval=FALSE>>=
reshape(d2, direction = "long",
        varying = c("ht_before", "wt_before",
                    "ht_after", "wt_after"),
        v.names = c("height", "weight"))
@

\subsection{Repeated application of reshape}

As an illustrative exercise, we can attempt to create an even more
elongated dataset that combines both height and weight measurements
into a single column.

<<>>=
dlong <- 
    reshape(d2, direction = "long",
            varying = c("ht_before", "wt_before",
                        "ht_after", "wt_after"),
            v.names = c("height", "weight"),
            timevar = "when", times = c("pre", "post"),
            idvar = "subject", ids = letters[1:n])
reshape(dlong, direction = "long",
        varying = c("height", "weight"),
        v.names = "combined",
        timevar = "what", times = c("height", "weight"))
@

Is it possible to achieve this result directly from the original wide
dataset \code{d2} using a single \code{reshape()} call?  It is
possible, though the resulting time variable will be composite (which
could subsequently be separated if required).

<<>>=
reshape(d2, direction = "long",
        v.names = "combined",
        varying = c("ht_before", "ht_after", "wt_before", "wt_after"),
        timevar = "when_what",
        times = c("pre_height", "post_height", "pre_weight", "post_weight"),
        idvar = "subject", ids = letters[1:n])
@

\section{Conversion from long to wide format}

Conversion from the long format to the wide format is generally more
straightforward.  We simulate long-format data consistent with our
hypothetical study design.

<<>>=
d3 <- data.frame(sex = sample(c("M", "F"), 2 * n, replace = TRUE),
                 ht = round(rnorm(2 * n, 165, 6), 1),
                 wt = round(rnorm(2 * n, 80, 6)),
                 subject = rep(1:n, 2),
                 when = rep(c("pre", "post"), each = n))
d3
@

To transform this dataset to wide format, the arguments \code{idvar}
and \code{timevar} must be supplied to \code{reshape()}.  By default,
all variables other than these two are treated as time-varying.  This
leads to an erroneous treatment of \code{sex} as time-varying in the
following example.

<<>>=
reshape(d3, direction = "wide",
        idvar = "subject", timevar = "when")
@

To designate certain variables as time-constant, the time-varying
variables must be explicitly identified via the \code{v.names}
argument.

<<eval=FALSE>>=
reshape(d3, direction = "wide",
        idvar = "subject", timevar = "when",
        v.names = c("ht", "wt"))
@

This invocation produces a warning because \code{sex} is not
genuinely time-constant in our simulated dataset \code{d3}.  Let us
correct this by creating a dataset where sex is constant per subject.

<<>>=
n <- 10
d4 <- data.frame(sex = rep(sample(c("M", "F"), n, replace = TRUE), 2),
                 ht = round(rnorm(2 * n, 165, 6), 1),
                 wt = round(rnorm(2 * n, 80, 6)),
                 subject = rep(1:n, 2),
                 when = rep(c("pre", "post"), each = n))
reshape(d4, direction = "wide",
        idvar = "subject", timevar = "when",
        v.names = c("ht", "wt"), sep = "_")
@

To explicitly define the resulting wide-format variable names instead
of relying on the automatically constructed defaults, we may employ
the \code{varying} argument, analogous to its use in wide-to-long
conversion.  As before, \code{varying} can be supplied as a vector of
variable names, with the same caveats regarding order applying.

<<>>=
reshape(d4, direction = "wide",
        idvar = "subject", timevar = "when",
        v.names = c("ht", "wt"),
        varying = c("h_before", "w_before", "h_after", "w_after"))
@

%% Pre 4.1.0: Error in varying[, i] : incorrect number of dimensions

When more than one time-varying variable is involved, it is safer to
avoid the vector form and instead supply \code{varying} as a list or
matrix.

<<>>=
reshape(d4, direction = "wide",
        idvar = "subject", timevar = "when",
        v.names = c("ht", "wt"),
        varying = list(c("h_before", "h_after"),
                       c("w_before", "w_after")))
@


\end{document}