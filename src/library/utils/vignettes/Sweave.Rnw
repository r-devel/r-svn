% !TeX encoding = UTF-8
% !TeX spellcheck = en
% File src/library/utils/vignettes/Sweave.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2002–2026 Friedrich Leisch and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

% Vignette metadata
% \VignetteIndexEntry{Sweave User Manual}
% \VignettePackage{utils}
% \VignetteDepends{tools, datasets, stats, graphics}

\title{Sweave User Manual}
\author{Friedrich Leisch and R Core Team}

\usepackage[round]{natbib}
\usepackage{graphicx, Rd}
\usepackage{listings}

\lstset{frame=trbl,basicstyle=\small\tt}
\usepackage{hyperref}
\usepackage{color}
\definecolor{Blue}{rgb}{0,0,0.8}
\hypersetup{%
  colorlinks,%
  plainpages=true,%
  linkcolor=black,%
  citecolor=black,%
  urlcolor=Blue,%
  pdfstartview={XYZ null null 1},%
  pdfview={XYZ null null null},%
  pdfpagemode=UseNone,%
  pdfauthor={Friedrich Leisch and R Core Team},%
  pdftitle={Sweave User Manual},%
  pdfsubject={R vignette documentation system}%
}

\newcommand{\I}[1]{#1}

\sloppy

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

Sweave provides a framework for mixing text and \R{} code for automatic
document generation. A single source file contains both documentation
text and \R{} code, which are then \emph{woven} into a final document
containing:
\begin{itemize}
 \item the documentation text,
 \item the \R{} code, and
 \item the output of the code (text, graphs).
\end{itemize}

This allows reports to be regenerated if input data change, and ensures
that the code to reproduce the analysis is documented in the same file
as the report. The \R{} code of the complete analysis is embedded into a
\LaTeX{} document\footnote{\url{https://www.ctan.org}} using the
\code{noweb} syntax \citep{ramsey:noweb} commonly used for literate
programming \citep{knuth:literate:1984}. Hence, the full power of
\LaTeX{} (for high‑quality typesetting) and \R{} (for data analysis) can
be used simultaneously. See \cite{leisch:sweave:2002} for more general
thoughts on dynamic report generation and pointers to related systems.

Sweave uses a modular concept with different drivers for translation.
Different drivers are needed for different text markup languages
(\LaTeX{}, HTML, etc.). Several CRAN packages provide support for other
word‑processing systems (see Appendix~\ref{sec:faq}).

\textbf{Note:} Sweave functionality described here (\Sexpr, chunk reuse,
syntax definitions) remains valid. However, in practice most modern
workflows use \pkg{knitr}, which extends Sweave’s ideas with more
flexibility and integration into R Markdown.

\section{\I{Noweb} files}
\label{sec:noweb}

\code{noweb} \citep{ramsey:noweb} is a simple literate‑programming tool
that allows combining program source code and documentation into a
single file. A \code{noweb} file consists of a sequence of code and
documentation segments, called \emph{chunks}:
\begin{description}
\item[Documentation chunks] start with a line beginning with an at sign
  (\verb|@|), followed by a space or newline. The rest of this line is a
  comment and ignored. Documentation chunks typically contain text in a
  markup language like \LaTeX{}. The chunk continues until a new code or
  documentation chunk is started. Sweave does not interpret the contents
  of documentation chunks, so chunk indicators are recognized even
  inside \LaTeX{} verbatim environments.

\item[Code chunks] start with \verb|<<|\code{\var{options}}\verb|>>=| at
  the beginning of a line; the rest of the line is a comment and ignored.
\end{description}

The default for the first chunk is documentation. In the simplest usage
of \command{noweb}, the options (if present) of code chunks give the
names of source code files, and the tool \command{notangle} can be used
to extract the code chunks. Multiple code chunks can share the same
name, and are concatenated when extracted.

\section{Sweave files}
\label{sec:sweavefile}

\subsection{A simple example}
Sweave source files are \code{noweb} files with additional syntax for
controlling the final output. Traditional \code{noweb} files use the
extension \file{.nw}, which is also valid for Sweave. Sweave additionally
recognizes \file{.rnw}, \file{.Rnw}, \file{.snw}, and \file{.Snw}. We
will use \file{.Rnw} throughout this document.

A minimal Sweave file is shown in Figure~\ref{fig:ex1.Rnw}, containing
two code chunks embedded in a simple \LaTeX{} document. Running:

<<>>=
rnwfile <- system.file("Sweave", "example-1.Rnw", package = "utils")
Sweave(rnwfile)
@

translates this into the \LaTeX{} document shown in
Figures~\ref{fig:ex1.tex} and~\ref{fig:ex1.pdf}. The latter can also be
created directly from within \R{} using:

<<>>=
tools::texi2pdf("example-1.tex")
@

The first difference between \file{example-1.Rnw} and
\file{example-1.tex} is that the \LaTeX{} style file \file{Sweave.sty}
is automatically loaded, providing environments for typesetting \R{}
input and output (\code{Sinput} and \code{Soutput}). Otherwise,
documentation chunks are copied without modification from
\file{example-1.Rnw} to \file{example-1.tex}.


\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{\Sexpr{rnwfile}}
  \end{minipage}
  \caption{A minimal Sweave file: \file{example-1.Rnw}.}
  \label{fig:ex1.Rnw}
\end{figure}


\section{Code chunks and options}

The real work of Sweave is done on the code chunks. The first code
chunk in \file{example-1.Rnw} has no name, so the default behavior of
Sweave is used: both the \R{} commands and their respective output are
transferred to the \LaTeX{} file, embedded in \code{Sinput} and
\code{Soutput} environments.

The second and third code chunks demonstrate Sweave extensions to the
\code{noweb} syntax. Code chunk names can be used to pass options to
Sweave which control the final output:
\begin{itemize}
\item \code{eval=FALSE} in the second chunk indicates that the code
      should not be evaluated. The code is reused in the third chunk
      (see Section~\ref{sec:chunkrefs}).
\item The third chunk is marked as a figure chunk (\code{fig=TRUE}),
      so Sweave creates (by default) a PDF file of the plot generated
      by the commands. A corresponding
      \verb|\includegraphics{example-1-003}| statement is inserted into
      the \LaTeX{} file.
\item \code{echo=FALSE} indicates that the \R{} input should not be
      included in the final document (no \code{Sinput} environment).
\end{itemize}

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{\Sexpr{rnwfile}}
  \end{minipage}
  \caption{A minimal Sweave file: \file{example-1.Rnw}.}
  \label{fig:ex1.Rnw}
\end{figure}

\section{Code chunks and options}

The real work of Sweave is done on the code chunks. The first code
chunk in \file{example-1.Rnw} has no name, so the default behavior of
Sweave is used: both the \R{} commands and their respective output are
transferred to the \LaTeX{} file, embedded in \code{Sinput} and
\code{Soutput} environments.

The second and third code chunks demonstrate Sweave extensions to the
\code{noweb} syntax. Code chunk names can be used to pass options to
Sweave which control the final output:
\begin{itemize}
\item \code{eval=FALSE} in the second chunk indicates that the code
      should not be evaluated. The code is reused in the third chunk
      (see Section~\ref{sec:chunkrefs}).
\item The third chunk is marked as a figure chunk (\code{fig=TRUE}),
      so Sweave creates (by default) a PDF file of the plot generated
      by the commands. A corresponding
      \verb|\includegraphics{example-1-003}| statement is inserted into
      the \LaTeX{} file.
\item \code{echo=FALSE} indicates that the \R{} input should not be
      included in the final document (no \code{Sinput} environment).
\end{itemize}

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{example-1.tex}
  \end{minipage}
  \caption{Running \code{Sweave("example-1.Rnw")} produces the file
    \file{example-1.tex}.}
  \label{fig:ex1.tex}
\end{figure}

\begin{figure}[htbp]
  \centering
  \fbox{\begin{minipage}{0.8\textwidth}
    \includegraphics[width=\textwidth]{example-1}
  \end{minipage}}
  \caption{The final document is created by running \command{pdflatex} on
    \file{example-1.tex}.}
  \label{fig:ex1.pdf}
\end{figure}


\subsection{Sweave options}

Options control how code chunks and their output (text, figures) are
transferred from the \file{.Rnw} file to the \file{.tex} file. All
options have the form \code{key=value}, where \code{value} can be a
number, string, or logical value. Multiple options can be specified at
once (comma‑separated). Logical options accept \code{TRUE}, \code{FALSE},
\code{T}, \code{F}, and case‑insensitive variants.

Options can be specified:
\begin{enumerate}
 \item Inside the angle brackets at the beginning of a code chunk,
       modifying behavior only for that chunk.
 \item Anywhere in a documentation chunk using
       \verb|\SweaveOpts{opt1=value1, opt2=value2, ...}|, which sets
       defaults for all subsequent chunks. A \verb|\SweaveOpts|
       statement in the preamble sets defaults for the entire document.
\end{enumerate}

Global options can also be specified in the environment variable
\env{SWEAVE\_OPTIONS}, or via the \option{--options=} flag of
\command{R CMD Sweave}.

Supported options depend on the driver in use. All drivers should at
least support:
\begin{description}
  \item[split=FALSE:] Logical. If \code{TRUE}, output is distributed
        over several files; if \code{FALSE}, all output is written to a
        single file.
  \item[label:] A text label for the code chunk, used for file‑name
        creation when \code{split=TRUE}. Labels also appear in comments
        added above chunks when processed by \command{Rtangle}, and as
        part of file names for figure chunks. Labels should contain only
        alphanumeric characters and \texttt{\#+-\_}. Avoid \texttt{.},
        which can cause confusion with file extensions.
\end{description}

The first (and only the first) option in a code chunk name can be
unnamed, in which case it is taken to be a label. For example:
\begin{quote}
  \verb|<<hello, split=FALSE>>|
\end{quote}
is equivalent to
\begin{quote}
  \verb|<<split=FALSE, label=hello>>|
\end{quote}
but
\begin{quote}
  \verb|<<split=FALSE, hello>>|
\end{quote}
is a syntax error. This convention maintains compatibility with
\code{noweb}. If only \verb|\SweaveOpts| is used for setting options,
Sweave files can be written to be fully compatible with \code{noweb}.

The help pages for \code{RweaveLatex} and \code{Rtangle} list the
options supported by the default \code{Sweave} and \code{Stangle}
drivers.

\subsection{Figure file names}

Figure file names are of the form \code{prefix-label.ext}, where:
\begin{itemize}
 \item \code{prefix} is set by \code{prefix.string}, or defaults to the
       basename of the output file.
 \item \code{label} is the chunk label, or the chunk number (001–999).
 \item \code{ext} is the graphics extension (\code{pdf}, \code{eps}, etc.).
\end{itemize}

For example, in \file{example-1.Rnw}, the PDF version of the boxplot is
\file{example-1-003.pdf}, since it is the third code chunk. If
\verb|\SweaveOpts{prefix.string=figures/fig}| is used, figures are placed
in the \verb|figures| subdirectory. The Sweave document should ensure
this directory exists before use.

\subsection{Using multiple input files}

\LaTeX{} files can include others via \verb|\input{}| commands. These
can also be used in Sweave files, but included files are processed only
by \LaTeX{}, not Sweave. To include files for Sweave processing, use
\verb|\SweaveInput{}|.

Included files should use the same Sweave syntax and encoding (UTF‑8)
as the main file.



\subsection{Using scalars in text}

Sweave supports limited use of \R{} object values directly in text
chunks. Any occurrence of \verb|\Sexpr|\verb|{|\code{expr}\verb|}| is
replaced by the string resulting from coercing the value of the
expression \code{expr} to a character vector; only the first element is
used. For example, \verb|\Sexpr{sqrt(9)}| is replaced by the string
\code{3}.

Expressions are evaluated in the same environment as code chunks, so
objects defined in earlier evaluated chunks are available. Expressions
may contain any valid \R{} code, except braces (\verb|{ }|), which are
not allowed. This is not a real limitation, since more complex
computations can be performed in a hidden code chunk and the result
then used inside \verb|\Sexpr|.

\subsection{Code chunk reuse}
\label{sec:chunkrefs}

Named code chunks can be reused in later chunks. For example:
\begin{quote}
\begin{verbatim}
 <<a>>=
 x <- 10
 @

 <<b>>=
 x + y
 @

 <<c>>=
 <<a>>
 y <- 20
 <<b>>
 @
\end{verbatim}
\end{quote}

This is equivalent to:
\begin{quote}
\begin{verbatim}
 <<c>>=
 x <- 10
 y <- 20
 x + y
 @
\end{verbatim}
\end{quote}

The chunk reference operator \verb|<<>>| takes only the chunk name as
its argument, with no additional Sweave options. It must occur at the
beginning of a line. References to unknown chunk names are omitted,
with a warning.

\subsection{Syntax definition}

So far we have only discussed Sweave files using \code{noweb} syntax,
which is the default. Sweave also allows redefining the syntax for
marking documentation and code chunks.

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{example-1.Stex}
  \end{minipage}
  \caption{A Sweave file using \LaTeX{} syntax: \file{example-1.Stex}.}
  \label{fig:ex1.Stex}
\end{figure}

Figure~\ref{fig:ex1.Stex} shows the example from
Figure~\ref{fig:ex1.Rnw} using the \code{SweaveSyntaxLatex} definition.
It can be created using:

<<>>=
SweaveSyntConv(rnwfile, SweaveSyntaxLatex)
@

Code chunks are then enclosed in \code{Scode} environments, and chunk
reuse is performed using \verb|\Scoderef{chunkname}|. All other operators
remain the same as in the \code{noweb}-style syntax.

The syntax used for a document is determined by the file extension:
files with extension \file{.Rtex} or \file{.Stex} are assumed to follow
the \LaTeX{}‑style syntax. Alternatively, syntax can be changed at any
point within the document using:

\begin{quote}
  \verb|\SweaveSyntax{SweaveSyntaxLatex}|
\end{quote}
or
\begin{quote}
  \verb|\SweaveSyntax{SweaveSyntaxNoweb}|
\end{quote}

at the beginning of a line in a documentation chunk. Syntax definitions
are lists of regular expressions for Sweave commands; see the two
default definitions above for examples.

\subsection{Encoding}

Sweave documents should use UTF‑8 encoding for portability and ease of
writing non‑English text. This can be enabled in the document preamble
with:
\begin{quote}
  \verb|\usepackage[utf8]{inputenc}|
\end{quote}

UTF‑8 provides broad coverage of international characters and is the
recommended encoding for modern Sweave documents.

Since \R{} 3.1.0, UTF‑8 encoding is handled preferentially. Sweave
converts R code to the local encoding in general, but leaves UTF‑8 code
untouched and outputs in UTF‑8. Besides the declaration scheme above, a
UTF‑8 encoding may also be declared with the \LaTeX{} comment:
\begin{quote}
  \verb|%\SweaveUTF8|
\end{quote}

For documentation sections, this is straightforward. For code sections,
where \LaTeX{} escapes cannot be used, the best practice is to use only
ASCII code to maximize portability. If non‑ASCII characters are needed,
ensure they match the input encoding declared in the preamble.

Inclusions add complexity: Sweave documents may include \R{} output,
\LaTeX{} or other Sweave files via \verb|\input{}| and
\verb|\SweaveInput{}|, bibliographies, and figures. It is the user’s
responsibility to ensure inclusions match the declared encoding.
Sweave documents should declare UTF‑8 encoding explicitly using
\verb|%\SweaveUTF8| in the source file.

Encoding mismatches can occur, for example when bibliographies or other
files use a different encoding than the main document. R output is also
affected by locale. Declaring UTF‑8 encoding ensures consistent handling
of text and symbols across platforms.

One common issue is quotes produced by \code{sQuote()} and
\code{dQuote()}. Two solutions are:
\begin{itemize}
  \item Suppress fancy quotes: \code{options(useFancyQuotes=FALSE)}
  \item Force UTF‑8 quotes: \code{options(useFancyQuotes="UTF-8")}
\end{itemize}

Figures are rarely affected by encoding, since they are bitmaps or
include encoding information. If needed, the \code{pdf.encoding} Sweave
option can configure the \code{pdf()} device appropriately.

\section{Tangling and weaving}

The user front‑ends of the Sweave system are the two \R{} functions
\code{Stangle()} and \code{Sweave()}, both contained in
package~\pkg{utils}. \code{Stangle()} extracts only the code chunks
from an \file{.Rnw} file and writes them to one or several files.
\code{Sweave()} runs the code chunks through \R{} and replaces them
with the respective input and/or output. \code{Stangle()} is actually
a wrapper for \code{Sweave()}, which uses a tangling driver instead of
a weaving driver by default. See:

<<eval=FALSE>>=
help("Sweave")
@

for more details and arguments of these functions.

\subsection{The \code{RweaveLatex} driver}

This driver transforms \file{.Rnw} files with \LaTeX{} documentation
chunks and \R{} code chunks into proper \LaTeX{} files (for typesetting
with either \command{latex} or \command{pdflatex}). See:

<<eval=FALSE>>=
help("RweaveLatex")
@

for details, including supported options.

\subsubsection{Writing to separate files}

If \code{split} is set to \code{TRUE}, then all text corresponding to
code chunks (the \code{Sinput} and \code{Soutput} environments) is
written to separate files. File names follow the form
\file{prefix.string-label.tex}. If several code chunks share the same
label, their outputs are concatenated. If a code chunk has no label,
the chunk number is used instead. The same naming scheme applies to
figures.

\subsubsection{\LaTeX{} style file}

The driver automatically inserts a \verb|\usepackage{Sweave.sty}|
command as the last line before the \verb|\begin{document}| statement
of the final \LaTeX{} file if no \verb|\usepackage{Sweave}| is found in
the source file. This style file defines the environments \code{Sinput}
and \code{Soutput} for typesetting code chunks. If you prefer not to
include the standard style file (for example, if you have your own
definitions for \code{Sinput} and \code{Soutput}), simply insert a
comment such as:

\begin{verbatim}
% \usepackage{Sweave}
\end{verbatim}


in the preamble of your \LaTeX{} file. This prevents automatic
insertion of the line.



\subsubsection{Figure sizes}

\file{Sweave.sty} sets the default \LaTeX{} figure width (independent of
the size of the generated EPS or PDF files). The current default is:
\begin{verbatim}
\setkeys{Gin}{width=0.8\textwidth}
\end{verbatim}

To use another width for figures automatically generated and included
by Sweave, add a line similar to the above \emph{after}
\verb|\begin{document}|. To disable the default width entirely, insert:
\begin{verbatim}
\usepackage[nogin]{Sweave}
\end{verbatim}
in the header of your file.

Note that a new graphics device is opened for each figure chunk (those
with option \code{fig=TRUE}). All graphical parameters set with
\code{par()} must therefore be specified in each figure chunk, as they
are reset when the device is closed.

Attention: The width/height parameters of \R{} graphics devices differ
from the arguments to \LaTeX{}’s \verb|\includegraphics| command. Sweave
options \code{width} and \code{height} affect the default size of the
produced EPS/PDF files, but not their size in the document. By default,
figures are scaled to 80\% of the text width. Use \verb|\setkeys{Gin}|
to modify figure sizes, or use explicit \verb|\includegraphics| commands
with the Sweave option \code{include=FALSE}.

\subsubsection{Prompts and text width}

By default, the driver uses prompts for input and continuation lines
from R’s \code{options()} settings. To set new prompts, use:
\begin{verbatim}
options(prompt = "MyR> ", continue = "...")
\end{verbatim}
See \code{help(options)} for details. Similarly, the output text width
is controlled by option \code{"width"}.

\subsubsection{Graphics devices}

The default graphics device for \code{fig=TRUE} chunks is \code{pdf()}.
Standard options \code{pdf}, \code{eps}, \code{png}, and \code{jpg}
allow one or more formats to be selected for a chunk or globally (via
\verb|\SweaveOpts|). For example:
\begin{verbatim}
<<figN, fig=TRUE, pdf=FALSE, png=TRUE>>
\end{verbatim}
will generate a PNG file, which \command{pdflatex} should automatically
include.

Custom graphics devices can also be defined. For example, to use
\code{cairo_pdf}:
\begin{verbatim}
my.Swd <- function(name, width, height, ...)
  grDevices::cairo_pdf(filename = paste(name, "pdf", sep = "."),
                       width = width, height = height)
\end{verbatim}

Specialized devices may require a custom shutdown function in place of
\verb|graphics.off()|. This can be supplied via a companion function
\verb|my.Swd.off|, called with no arguments.

For a complete example, see
\file{src/library/utils/tests/customgraphics.Rnw} in the \R{} sources.

\subsection{The \code{Rtangle} driver}

This driver extracts \R{} code chunks from a \file{.Rnw} file. Code
chunks can be written to one large file or separate files (one per
chunk). Options \code{split}, \code{prefix}, and \code{prefix.string}
have the same defaults and interpretation as for the
\code{RweaveLatex} driver. Use the standard \code{noweb} tool
\command{notangle} if chunks other than \R{} code should be extracted.
See:

<<eval=FALSE>>=
help("Rtangle")
@

for details.

Note that \code{split=TRUE} rarely makes sense, as the files produced
are often interdependent and need to be run in a specific order, which
is not necessarily alphabetical.

\section{Adding Sweave Drivers}

Adding drivers is relatively straightforward by modeling them on the
existing \code{RweaveLatex} and \code{Rtangle} drivers.\footnote{If you
copy, be careful not to infringe R‑core’s copyright: copyright notices
in the \R{} sources must also be copied.}

A Sweave driver is a function of no arguments which returns a list of
five functions:
\begin{description}
\item{\code{setup(file, syntax, \dots)}:} Set up the driver, e.g.,
open the output file. Returns an object passed to subsequent functions.
This should be a list containing a component \code{options}, a named
list of default settings for \code{runcode}.
\item{\code{runcode(object, chunk, options)}:} Process a code chunk.
Returns a possibly updated \code{object}.
\item{\code{writedoc(object, chunk)}:} Write out a documentation chunk.
Returns a possibly updated \code{object}.
\item{\code{finish(object, error)}:} Finish up, or clean up if
\code{error} is true.
\item{\code{checkopts(options)}:} Convert/validate \code{options} given
as a named list of character strings.
\end{description}

The \code{setup} function should include a \code{\ldots} argument. It
will be passed additional arguments from a \code{Sweave()} call. In
future, Sweave may itself set options and pass them on, such as the
encoding used for the text to be processed.

\bibliographystyle{jss}
\bibliography{Sweave}

\newpage
\appendix

\section{Frequently Asked Questions}
\label{sec:faq}

\subsection{How can I get Emacs to automatically recognize files in Sweave format?}

Recent versions of \abbr{ESS} (Emacs Speaks Statistics,
\url{https://ESS.R-project.org/}) automatically recognize files with
extension \file{.Rnw} as Sweave files and enable the correct modes.
Please follow the instructions on the ESS homepage for installation.

\subsection{Can I run Sweave directly from a shell?}

Yes. For example, when writing makefiles it can be useful to run Sweave
directly from a shell rather than starting \R{} manually. This can be
done with:
\begin{verbatim}
R CMD Sweave file.Rnw
\end{verbatim}

\subsection{Why does \LaTeX{} not find my EPS and PDF graphic files when the file name contains a dot?}

Sweave uses the standard \LaTeX{} package \pkg{graphicx} to handle
graphic files, which automatically chooses the type of file provided
the basename in \verb|\includegraphics{}| has no extension. Problems
arise if the Sweave file name contains dots: \file{foo.Rnw} is fine,
while \file{foo.bar.Rnw} is not.

\subsection{Empty figure chunks give \LaTeX{} errors.}

If a code chunk with \code{fig=TRUE} does not call any plotting
functions, invalid PDF/EPS files may be created. Sweave cannot know if
the code actually plotted something, so it will attempt to include the
graphics, which fails.

\subsection{Why do R lattice graphics not work?}

In recent versions of Sweave they do, provided they would when run at
the command line. Some calls (e.g., those inside loops) need to be
explicitly wrapped in \code{print()}.

\subsection{How can I get Black \& White lattice graphics?}

To specify strip panels with transparent backgrounds and black‑and‑white
graphs globally, use:
\begin{verbatim}
<<...>>=
library(lattice)
ltheme <- canonical.theme(color = FALSE)     ## in-built B&W theme
ltheme$strip.background$col <- "transparent" ## change strip bg
lattice.options(default.theme = ltheme)      ## set as default
@
\end{verbatim}

\subsection{Creating several figures from one figure chunk does not work.}

Sweave allows only one graph per figure chunk. It opens a graphics
device before executing the code and closes it afterwards. To plot in a
loop, use explicit device management:
\begin{verbatim}
<<results=tex,echo=FALSE>>=
for(i in 1:4){
   fname <- paste("myfile", i, ".pdf", sep = "")
   pdf(file = fname, width = 6, height = 6)
   plot(rnorm(100)+i)
   dev.off()
   cat("\\includegraphics{", fname, "}\n\n", sep = "")
}
@
\end{verbatim}

\subsection{How can I set default \code{par()} settings for figure chunks?}

Because Sweave opens a new device for each figure chunk, \code{par()}
settings must be inside each chunk. To avoid repetition, use a hook
function:
\begin{verbatim}
options(SweaveHooks = list(fig = function() par(bg = "red", fg = "blue")))
\end{verbatim}

\subsection{How can I change the formatting of R input and output chunks?}

Sweave uses the \pkg{fancyvrb} package for formatting all \R{} code and
text output. \pkg{fancyvrb} allows fine control over verbatim layout.
To change defaults, modify the definitions of \code{Sinput} and
\code{Soutput} in \file{Sweave.sty}.

\subsection{How can I change the line length of R input and output?}

Sweave respects R’s usual line length setting:
\begin{verbatim}
options(width = 40)
\end{verbatim}
Lines will then be formatted to at most 40 characters.

\subsection{Can I use Sweave for Word files?}

Not directly. Package~\CRANpkg{officer} provides functionality to
manipulate Microsoft Word documents from R.

\subsection{Can I use Sweave for HTML files?}

Yes. Package \CRANpkg{R2HTML} provides a driver for using Sweave with
HTML rather than \LaTeX.

\subsection{After loading package \pkg{R2HTML} Sweave doesn't work properly!}

Package \CRANpkg{R2HTML} registers a Sweave driver for HTML files using
the same file extensions as the default \code{noweb} syntax. This can
override the default syntax. To restore the default, use:
\begin{verbatim}
options(SweaveSyntax = "SweaveSyntaxNoweb")
\end{verbatim}
or call Sweave with:
\begin{verbatim}
Sweave(..., syntax = "SweaveSyntaxNoweb")
\end{verbatim}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
