% File src/library/utils/vignettes/Sweave.Rnw
% Part of the R package, https://www.R-project.org
% Copyright 2002-2022 Friedrich Leisch and the R Core Team
% Distributed under GPL 2 or later

\documentclass[a4paper]{article}

%\VignetteIndexEntry{Sweave User Manual}
%\VignettePackage{utils}
%\VignetteDepends{tools, datasets, stats, graphics}

\title{Sweave User Manual}
\author{Friedrich Leisch and R Core Team}

\usepackage[round]{natbib}
\usepackage{graphicx, Rd}
\usepackage{listings}

\lstset{frame=trbl,basicstyle=\small\tt}
\usepackage{hyperref}
\usepackage{color}
\definecolor{Blue}{rgb}{0,0,0.8}
\hypersetup{%
colorlinks,%
plainpages=true,%
linkcolor=black,%
citecolor=black,%
urlcolor=Blue,%
%pdfstartview=FitH,% or Fit
pdfstartview={XYZ null null 1},%
pdfview={XYZ null null null},%
pdfpagemode=UseNone,% for no outline
pdfauthor={Friedrich Leisch and R Core Team},%
pdftitle={Sweave User Manual},%
pdfsubject={R vignette documentation system}%
}

\newcommand{\I}[1]{#1}

\sloppy

\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

Sweave constitutes a flexible framework for the integration of
documentation text and executable \R{} code within a single source
file, enabling the automatic generation of final documents. The source
file interleaves explanatory text with \R{} code segments, which are
subsequently \emph{woven} into a coherent document containing both the
explanatory prose and the results of code execution, which may include
formatted output, computed values, or graphical figures. This paradigm
allows reports to be regenerated whenever underlying data change,
while simultaneously documenting the precise analytical steps within
the same file that produces the report. The complete \R{} analysis code
is embedded within a \LaTeX{} document\footnote{\url{https://www.ctan.org}}
using the \code{noweb} literate programming syntax \citep{flm:Ramsey:1998}.
Consequently, the combined capabilities of \LaTeX{} (for high-quality
typesetting) and \R{} (for statistical computation and graphics) are
available simultaneously. For broader discussion of dynamic report
generation and comparisons with alternative systems, consult
\cite{e1071-papers:Leisch:2002} and references therein.

Sweave employs a modular design based on interchangeable \emph{drivers}
that handle the translation from source to output format. Different
drivers are clearly required for distinct text markup languages
(\LaTeX{}, HTML, etc.). Several packages available on CRAN extend
Sweave to support additional document processing systems (see
Appendix~\ref{sec:faq}).


\section{\I{Noweb} files}
\label{sec:noweb}

The \code{noweb} system \citep{flm:Ramsey:1998} is a straightforward
literate-programming tool that permits the combination of program
source code and its accompanying documentation in a single file.  A
\code{noweb} file is a plain text file composed of an alternating
sequence of documentation and code segments, termed \emph{chunks}:
\begin{description}
\item[Documentation chunks] commence with a line whose first character
  is an at sign (\verb|@|), followed immediately by a space or a
  newline. The remainder of this line is treated as a comment and
  ignored. Typically, documentation chunks contain text formatted in a
  markup language such as \LaTeX{}. The chunk continues until the
  beginning of a new code or documentation chunk. Note that Sweave does
  not interpret the contents of documentation chunks; therefore, chunk
  indicators appearing within \LaTeX{} verbatim environments will still
  be recognized as such.

\item[Code chunks] begin with a line starting with
  \verb|<<|\code{\var{options}}\verb|>>=|; as with documentation chunks, the
  remainder of the line is a comment and ignored.
\end{description}
By default, the initial chunk of a file is a documentation chunk.

In the simplest usage of the \command{noweb} tool, the optional
\code{options} portion of a code chunk provides the name of an output
source code file, and the \command{notangle} utility can extract and
concatenate all code chunks sharing that name. The \code{noweb} system
includes additional mechanisms for cross-referencing between code
chunks (such as the \verb|[[...]]| operator); these features are not
currently utilized or supported by Sweave and will not be described
further here.


\section{Sweave files}
\label{sec:sweavefile}

\subsection{A simple example}

Sweave source files are \code{noweb} files augmented with additional
syntax that provides finer control over the final output. Traditional
\code{noweb} files commonly use the extension \file{.nw}, which is
also perfectly acceptable for Sweave files (and fully supported by the
software). Additionally, Sweave recognizes the extensions \file{.rnw},
\file{.Rnw}, \file{.snw}, and \file{.Snw} as indicating a
\code{noweb} file that includes Sweave extensions. Throughout this
document we will employ the \file{.Rnw} extension.

Figure~\ref{fig:ex1.Rnw} displays a minimal Sweave file, consisting of
two code chunks embedded within a simple \LaTeX{} document. Executing
<<>>=
rnwfile <- system.file("Sweave", "example-1.Rnw", package = "utils")
Sweave(rnwfile)
@
translates this source into the \LaTeX{} document shown in
Figures~\ref{fig:ex1.tex} and~\ref{fig:ex1.pdf}. The PDF document can
also be produced directly from within \R{} via
<<>>=
tools::texi2pdf("example-1.tex")
@

The first notable difference between \file{example-1.Rnw} and
\file{example-1.tex} is the automatic inclusion of the \LaTeX{} style
file \file{Sweave.sty}, which defines environments for typesetting \R{}
input and output (the \LaTeX{} environments \code{Sinput} and
\code{Soutput}). Apart from this, the documentation chunks are copied
verbatim from the source to the output file.

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{\Sexpr{rnwfile}}
  \end{minipage}
  \caption{A minimal Sweave file: \file{example-1.Rnw}.}
  \label{fig:ex1.Rnw}
\end{figure}

The substantive work performed by Sweave occurs on the code chunks.
The first code chunk lacks a name, so the default Sweave behavior is
applied: both the \R{} commands and their textual output are transferred
to the \LaTeX{} file, embedded within \code{Sinput} and \code{Soutput}
environments, respectively.

The second and third code chunks illustrate a Sweave extension to the
basic \code{noweb} syntax: the name portion of a code chunk can be
used to pass options that control the processing of that chunk.
\begin{itemize}
\item The option \code{eval=FALSE} for the second chunk indicates that
  the contained code should not be evaluated at that point. The code is
  subsequently reused in the third chunk (details are provided in
  Section~\ref{sec:chunkrefs}).
\item The third chunk is designated as a figure chunk via
  \code{fig=TRUE}, causing Sweave to generate (by default) a PDF file
  containing the plot produced by the chunk's commands. Additionally, a
  \verb|\includegraphics{example-1-003}| statement is inserted into
  the \LaTeX{} file (specifics regarding figure file naming are
  discussed later in this manual).
\item The option \code{echo=FALSE} specifies that the \R{} input
  commands should not appear in the final document (no \code{Sinput}
  environment is generated).
\end{itemize}

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{example-1.tex}
  \end{minipage}
  \caption{Running \code{Sweave("example-1.Rnw")} produces the file
    \file{example-1.tex}.}
  \label{fig:ex1.tex}
\end{figure}

\begin{figure}[htbp]
  \centering
  \fbox{\begin{minipage}{0.8\textwidth}
    \includegraphics[width=\textwidth]{example-1}
  \end{minipage}}
  \caption{The final document is created by processing
    \file{example-1.tex} with \command{pdflatex}.}
  \label{fig:ex1.pdf}
\end{figure}


\subsection{Sweave options}

Options govern how code chunks and their associated output (textual
output, figures) are transferred from the \file{.Rnw} source to the
\file{.tex} output file. All options follow the form
\code{\var{key}=\var{value}}, where \code{\var{value}} may be a
numeric, character, or logical value. Multiple options can be
specified simultaneously (separated by commas); each option must be
assigned a value (which may not contain a comma or an equals sign).
Logical options accept the values \code{TRUE}, \code{FALSE},
\code{T}, \code{F}, as well as lower-case and capitalized variants
of the first two.

Within a \file{.Rnw} file, options can be specified in two ways:
\begin{enumerate}
 \item Within the angle brackets at the start of a code chunk,
   affecting \emph{only that specific chunk}; or
 \item Anywhere within a documentation chunk using the command %
   \begin{quote}
     \verb|\SweaveOpts{|\code{\var{opt1}=\var{value1}, \var{opt2}=\var{value2}, ..., \var{optN}=\var{valueN}}\verb|}|
   \end{quote}
   which modifies the default behavior for all subsequent code chunks
   in the document. Consequently, an \verb|\SweaveOpts| statement in
   the document preamble sets defaults for the entire document.
\end{enumerate}
Additionally, global options can be supplied via the environment
variable \env{SWEAVE\_OPTIONS} (as a comma-separated list of
\code{\var{key}=\var{value}} pairs) or through the
\option{--options=} flag of \command{R CMD Sweave}.

The set of supported options depends on the active driver. All drivers
are expected to support at least the following options (default values
are shown where applicable):
\begin{description}
  \item[split=FALSE:] a logical value. If \code{TRUE}, output is
   distributed across multiple files; if \code{FALSE}, all output is
   written to a single file. Specifics depend on the driver.

 \item[label:] a text label identifying the code chunk. This label is
   used in constructing file names when \code{split=TRUE}. It also
   appears in the comments inserted above the chunk when the file is
   processed by \command{Rtangle} (provided the \code{annotate} option
   is true, which is the default), and forms part of the file names
   generated for figures.

   Because labels may become part of file names, they should consist
   solely of alphanumeric characters and the symbols
   \texttt{\#+\-\_}. (Including \texttt{.} can cause confusion with
   file extensions.)
\end{description}

The first (and only the first) item within the angle brackets of a
code chunk may optionally be unnamed; in that case it is interpreted
as a label. For example,
\begin{quote}
  \verb|<<hello, split=FALSE>>|
\end{quote}
is equivalent to
\begin{quote}
  \verb|<<split=FALSE, label=hello>>|
\end{quote}
whereas
\begin{quote}
  \verb|<<split=FALSE, hello>>|
\end{quote}
produces a syntax error. The provision for an unnamed first argument
as a label ensures compatibility with standard \code{noweb} syntax. If
options are set exclusively via \verb|\SweaveOpts| statements, Sweave
files can be written to be fully compatible with \code{noweb} (since
only file names would appear in code chunk names).

Note that \code{split=TRUE} should \textbf{not} be used within package
vignettes.

The help pages for \code{RweaveLatex} and \code{Rtangle} enumerate the
options supported by the default \code{Sweave} and \code{Stangle}
drivers.

Now we provide the promised details concerning figure file names.
These follow the pattern \code{\var{prefix}-\var{label}.\var{ext}}.
Here \code{\var{prefix}} can be set via the option
\code{prefix.string}; otherwise it defaults to the basename of the
output file (which, unless specified otherwise, is the basename of the
input file). \code{\var{label}} is the label of the code chunk if one
is provided; otherwise it is the sequential number of the code chunk,
padded to three digits (001 to 999). \code{\var{ext}} is the
appropriate file extension for the selected graphics format (e.g.,
\code{pdf}, \code{eps}, \ldots{}). Thus, for the
\file{example-1.Rnw} file, the PDF version of the boxplot is
\file{example-1-003.pdf}, as it is the third code chunk in the
document. Note that if \code{prefix.string} is employed, it may
include a directory path as part of the prefix; for example, setting
\verb|\SweaveOpts{prefix.string=figures/fig}| will direct
auto-generated figures to the sub-directory \verb|figures|. The Sweave
document must ensure this directory exists before it is needed.

\subsection{Using multiple input files}

\LaTeX{} documents can incorporate other files via \verb|\input{}|
commands. While these can also be used in Sweave files, such included
files are processed directly by \LaTeX{} and are not interpreted by
Sweave. The equivalent mechanism to have an included file processed by
Sweave is the \verb|\SweaveInput{}| command.

Included files should employ the same Sweave syntax (see below) and
character encoding as the main file.

\subsection{Embedding scalar values in text}

Sweave provides limited support for incorporating the values of \R{}
objects directly within documentation text. Any occurrence of
\verb|\Sexpr|\verb|{|\code{\var{expr}}\verb|}|
is replaced by the character string resulting from coercing the
evaluation of \code{expr} to a character vector; only the first
element of this vector is used. For example,
\verb|\Sexpr{sqrt(9)}| will be replaced by the string \code{'3'}
(without quotation marks).

The expression is evaluated within the same environment as the code
chunks, allowing access to all objects defined in preceding code
chunks that have been executed. The expression may contain any valid
\R{} code, with the sole restriction that braces (\verb|{ }|) are not
permitted. (This is not a practical limitation, as more complex
computations can be performed in a hidden code chunk, with the result
then referenced via \verb|\Sexpr|.)

\subsection{Code chunk reuse}
\label{sec:chunkrefs}

Named code chunks can be referenced and reused within later code
chunks in the document. Consider the simple example:
\begin{quote}% NB: this is indented to avoid interpretation by Sweave.
\begin{verbatim}
 <<a>>=
 x <- 10
 @

 <<b>>=
 x + y
 @

 <<c>>=
 <<a>>
 y <- 20
 <<b>>
 @
\end{verbatim}
\end{quote}
This is equivalent to defining the last code chunk as:
\begin{quote}
\begin{verbatim}
 <<c>>=
 x <- 10
 y <- 20
 x + y
 @
\end{verbatim}
\end{quote}

The chunk reference operator \verb|<<>>| accepts only the name of the
chunk as its argument; no additional Sweave options are permitted. It
must appear at the beginning of a line.

References to non-existent chunk names are silently omitted, with a
warning issued.

\subsection{Syntax definition}

The preceding discussion assumed the use of the default \code{noweb}
syntax. However, Sweave permits the user to redefine the syntax markers
for documentation and code chunks, as well as for embedding scalars in
text and referencing other code chunks.

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.9\textwidth}
    \lstinputlisting{example-1.Stex}
  \end{minipage}
  \caption{An Sweave file using \LaTeX{} syntax: \file{example-1.Stex}.}
  \label{fig:ex1.Stex}
\end{figure}

Figure~\ref{fig:ex1.Stex} shows the example from
Figure~\ref{fig:ex1.Rnw} recast using the \code{SweaveSyntaxLatex}
syntax definition. It can be created via:
<<>>=
SweaveSyntConv(rnwfile, SweaveSyntaxLatex)
@

In this syntax, code chunks are delimited by \code{Scode}
environments, and code chunk reuse is accomplished with
\verb|\Scoderef{|\code{\var{chunkname}}\verb|}|. All other operators
(e.g., \verb|\Sexpr|, \verb|\SweaveOpts|) remain identical to those
in the \code{noweb}-style syntax.

The syntax used for a document is determined by the file extension:
files with extension\footnote{or their lowercase equivalents, for
  convenience on case-insensitive file systems.} \file{.Rtex} or
\file{.Stex} are assumed to follow the \LaTeX-style syntax.
Alternatively, the syntax can be changed at any point within the
document by placing one of the commands
\begin{quote}
  \verb|\SweaveSyntax{SweaveSyntaxLatex}|
\end{quote}
or
\begin{quote}
  \verb|\SweaveSyntax{SweaveSyntaxNoweb}|
\end{quote}
at the beginning of a line within a documentation chunk. Syntax
definitions are simply lists of regular expressions corresponding to
the various Sweave commands; see the two default definitions mentioned
above for examples.

\subsection{Encoding}

Traditional \LaTeX{} documents are written entirely in ASCII,
employing \LaTeX{} escape sequences such as \verb|\'e| for accented
characters. This can be inconvenient for documents in non-English
languages. An alternative is to select an input encoding via a
statement such as
\begin{quote}
  \verb|\usepackage[latin1]{inputenc}|
\end{quote}
in the document preamble, instructing \LaTeX{} to translate the input
characters to its internal representations. A wide range of input
encodings are supported, at least partially, and the more recent
\LaTeX{} package \pkg{inputenx} provides extended support. Other
encodings commonly encountered in Sweave documents include
\code{latin9}, \code{utf8}, and \code{ansinew} (the Windows CP1252
codepage). Broader coverage\footnote{including Eastern European,
  Greek, and Hebrew characters.} of UTF-8 can be obtained by:
\begin{quote}
  \verb|\usepackage[utf8]{inputenx}|
  \verb|\input{ix-utf8enc.dfu}|
\end{quote}

As of \R{} 3.1.0, UTF-8 encoding receives preferential treatment. While
Sweave generally converts \R{} code to the local encoding, it preserves
UTF-8 code in that encoding and outputs it accordingly. In addition to
the declaration schemes above, a UTF-8 encoding may be indicated by the
\LaTeX{} comment:
\begin{quote}
  \verb|%\SweaveUTF8|
\end{quote}

The preceding paragraphs concern documentation sections; however, code
sections cannot utilize \LaTeX{} escape sequences. The primary
recommendation is to restrict code sections to ASCII characters to
maximize portability. Nonetheless, \R{} code in the declared input
encoding can be included if necessary.

A further complication arises from inclusions: the final vignette may
incorporate \R{} output, other \LaTeX{} or Sweave files via
\verb|\input{}| and \verb|\SweaveInput{}| commands, bibliographies,
and figures. It is the user's responsibility to ensure that included
text conforms to the declared input encoding. While \LaTeX{} permits
changing the input encoding via
\begin{quote}
  \verb|\inputencoding{|\code{\var{something}}\verb|}|
\end{quote}
statements, these may not interact well with Sweave processing. Since
\verb|\usepackage[latin1]{inputenc}| is typically illegal \LaTeX{}
syntax within an included file, it is simplest to declare the encoding
to Sweave using the \verb|%\SweaveUTF8| comment.

Care must also be taken to ensure that BibTeX references are encoded
consistently with the main document; it is easy to inadvertently
combine UTF-8 references with a Latin-1 document, or vice versa.

The encoding of \R{} output is largely under user control. If a
Latin-1 Sweave document is processed by \R{} in a Latin-1 locale, or a
UTF-8 document in a UTF-8 locale, problems are most likely to arise
from handling data in a different encoding. It may be necessary to
explicitly declare the document's encoding to cover \R{} output,
even if the document itself is purely ASCII. A common issue involves
the quotes produced by \code{sQuote()} and \code{dQuote()}: these will
be UTF-8 characters when \R{} runs in a UTF-8 locale, and CP1252
characters when Sweave is executed from \command{Rgui.exe} on Windows.
Potential solutions include suppressing fancy quotes via
\code{options(useFancyQuotes=FALSE)} or forcing UTF-8 quotes with
\code{options(useFancyQuotes="UTF-8")}.

The encoding of figures is usually not problematic, as figures are
either bitmaps or contain embedded encoding information; however, it
may be necessary to use the Sweave option \code{pdf.encoding} to
configure the \code{pdf()} device appropriately.


\section{Tangling and weaving}

The user-facing interfaces of the Sweave system are the two \R{}
functions \code{Stangle()} and \code{Sweave()}, both residing in
package~\pkg{utils}. \code{Stangle} extracts only the code chunks from
an \file{.Rnw} file and writes them to one or more output files.
\code{Sweave()} executes the code chunks through \R{} and replaces them
with their corresponding input and/or output. Internally,
\code{Stangle} is a wrapper for \code{Sweave} that employs a tangling
driver rather than a weaving driver. Consult
<<eval=FALSE>>=
help("Sweave")
@
for further details and argument descriptions.

\subsection{The \code{RweaveLatex} driver}

This driver transforms \file{.Rnw} files containing \LaTeX{}
documentation chunks and \R{} code chunks into proper \LaTeX{} files
(suitable for processing with standard \command{latex} or
\command{pdflatex}). See
<<eval=FALSE>>=
help("RweaveLatex")
@
for comprehensive details, including the list of supported options.

\subsubsection{Writing to separate files}

When \code{split} is set to \code{TRUE}, all text corresponding to
code chunks (the \code{Sinput} and \code{Soutput} environments) is
written to separate files. The file names follow the pattern
\file{prefix.string-label.tex}; if multiple code chunks share the same
label, their outputs are concatenated. If a code chunk lacks a label,
its sequential number is used instead. The same naming scheme applies
to figure files. Care must be taken to ensure that generated file names
are valid and not excessively long for the operating system's file
naming limitations (some file systems recognize only the first 13
characters).

\subsubsection{\LaTeX{} style file}

The driver automatically inserts a \verb|\usepackage{Sweave.sty}|
command as the last line before \verb|\begin{document}| in the final
\LaTeX{} file, provided no \verb|\usepackage{Sweave}| statement is
found in the Sweave source file. This style file defines the
\code{Sinput} and \code{Soutput} environments for typesetting code
chunks. If you prefer not to include the standard style file (for
example, because you have custom definitions for these environments
elsewhere), simply insert a comment such as
\begin{verbatim}
% \usepackage{Sweave}
\end{verbatim}
in the preamble of your \LaTeX{} file; this will prevent automatic
insertion.

\subsubsection{Figure sizes}

\file{Sweave.sty} sets a default \emph{\LaTeX{}} figure width (which
operates independently of the actual dimensions of the generated EPS or
PDF files). The current default is:
\begin{verbatim}
\setkeys{Gin}{width=0.8\textwidth}
\end{verbatim}
If a different width is desired for figures automatically generated and
included by Sweave, a similar line may be added \emph{after}
\verb|\begin{document}|. To suppress any default width specification,
insert \verb|\usepackage[nogin]{Sweave}| in the document header. Note
that a new graphics device is opened for each figure chunk (i.e., each
chunk with option \code{fig=TRUE}); consequently, all graphical
parameters set via \code{par()} must be specified within each
individual figure chunk and are discarded after that chunk concludes
(because the device is closed upon exiting the chunk).

Caution: The width and height parameters of the \R{} graphics devices
should not be confused with the corresponding arguments to the \LaTeX{}
\verb|\includegraphics| command. The Sweave options \code{width} and
\code{height} are passed to the \R{} graphics device and thus affect
the default size of the produced EPS or PDF files. They do not directly
control the size of figures in the final document; by default, figures
will occupy 80\% of the current text width. To modify the displayed
figure size, use \verb|\setkeys{Gin}| or employ explicit
\verb|\includegraphics| commands in conjunction with the Sweave option
\code{include=FALSE}.

\subsubsection{Prompts and text width}

By default, the driver obtains the prompts used for input lines and
continuation lines from \R{}'s \code{options()} settings. To modify
these prompts, use something like:
\begin{verbatim}
options(prompt = "MyR> ", continue = "...")
\end{verbatim}
see \code{help(options)} for details. Similarly, the output text width
is governed by the \code{"width"} option.

\subsubsection{Graphics devices}

The default graphics device for chunks with \code{fig=TRUE} is
\code{pdf()}. The standard options \code{pdf}, \code{eps},
\code{png}, and \code{jpg} allow selection of one or more of these
formats for a particular chunk or (via \verb|\SweaveOpts|) for the
entire document. It can be convenient to select PNG for a specific
figure chunk using something like
\verb|<<figN, fig=TRUE, pdf=FALSE, png=TRUE>>|; \command{pdflatex}
should then automatically include the corresponding \abbr{PNG} file.

Custom graphics devices can be defined and selected via the option
\code{grdevice=my.Swd}, where the device function (here
\code{my.Swd}) is defined in a hidden code chunk. For example, to
utilize the \code{cairo\_pdf} device:
\begin{verbatim}
my.Swd <- function(name, width, height, ...)
  grDevices::cairo_pdf(filename = paste(name, "pdf", sep = "."),
                       width = width, height = height)
\end{verbatim}
Specialized custom graphics devices may require a customized shutdown
procedure in place of \verb|graphics.off()|; this can be supplied
\emph{via} a companion function \verb|my.Swd.off|, which is called
with no arguments.

For a complete example, refer to the file
\file{src/library/utils/tests/customgraphics.Rnw} in the \R{} source
distribution.

\subsection{The \code{Rtangle} driver}

This driver extracts \R{} code chunks from a \file{.Rnw} file. Code
chunks can be written either to a single file or to separate files
(one per code chunk). The options \code{split}, \code{prefix}, and
\code{prefix.string} have the same defaults and interpretation as for
the \code{RweaveLatex} driver. To extract non-\R{} code chunks, use the
standard \code{noweb} command-line tool \command{notangle}. See
<<eval=FALSE>>=
help("Rtangle")
@
for further details.

Note that \code{split=TRUE} is rarely useful, as the resulting files
are often interdependent and must be executed in a specific order,
which frequently does not correspond to alphabetical order.

\section{Adding Sweave Drivers}

Adding new drivers is relatively straightforward by modeling them
on\footnote{If copying code, ensure that R-core's copyright notices
  are also copied to avoid infringement.} the existing
\code{RweaveLatex} and \code{Rtangle} drivers.

An Sweave driver is a function of no arguments that returns a list
containing five functions:
\begin{description}
\item{\code{setup(file, syntax, \dots)}:} Initializes the driver,
    e.g., opens output files. Its return value is an object passed to
    the subsequent three functions and may be updated by the next two.
    The value should be a list containing at least a component
    \code{options}, a named list of default settings for the options
    required by \code{runcode}.
\item{\code{runcode(object, chunk, options)}:} Processes a code
    chunk. Returns a possibly updated \code{object}. Argument
    \code{chunk} is a character vector of the chunk's lines, and
    \code{options} is the options list for this chunk.
\item{\code{writedoc(object, chunk)}:} Writes a documentation chunk.
    Returns a possibly updated \code{object}.
\item{\code{finish(object, error)}:} Performs finalization, or cleanup
    if \code{error} is true.
\item{\code{checkopts(options)}:} Validates and converts
    \code{options} provided as a named list of character strings.
\end{description}

Note that the \code{setup} function should include a \code{\ldots}
argument. It will receive additional arguments from a \code{Sweave()}
call; in the future, \code{Sweave} may itself set options (such as the
text encoding) and pass them to the setup function.

\bibliographystyle{jss}
\bibliography{Sweave}

\newpage
\appendix


\section{Frequently Asked Questions}
\label{sec:faq}

  \subsection{How can I configure Emacs to automatically recognize
    Sweave format files?}

  Recent versions of \abbr{ESS} (Emacs Speaks Statistics,
  \url{https://ESS.R-project.org/}) automatically recognize files with
  extension \file{.Rnw} as Sweave files and activate the appropriate
  editing modes. Please follow the installation instructions on the
  \abbr{ESS} website.

  \subsection{Can I run Sweave directly from a shell command line?}

  For integration with makefiles or batch processing, it can be useful
  to invoke Sweave directly from a shell rather than manually starting
  \R{} and then calling Sweave. This is easily accomplished using:
\begin{verbatim}
R CMD Sweave file.Rnw
\end{verbatim}

  \subsection{Why does \LaTeX{} fail to locate my EPS and PDF graphic
     files when the file name contains a dot?}

   Sweave employs the standard \LaTeX{} package \pkg{graphicx} to
   handle graphic files, which automatically selects the correct file
   type provided the basename supplied to \verb|\includegraphics{}|
   lacks an extension. Consequently, problems may arise if the
   basename of your Sweave file contains dots: \file{foo.Rnw} is
   acceptable, whereas \file{foo.bar.Rnw} is not.

   \subsection{Empty figure chunks produce \LaTeX{} errors.}

   When a code chunk with \code{fig=TRUE} does not execute any plotting
   commands, invalid PDF (or EPS) files may be generated. Sweave cannot
   determine whether the code within a figure chunk actually produces
   graphical output, so it attempts to include the (potentially
   corrupt) graphics file, which inevitably fails.

   \subsection{Why do R lattice graphics sometimes fail to appear?}

   In recent versions of Sweave they function correctly if they would
   work at the command line: certain calls (e.g., those inside loops)
   must be explicitly wrapped in \code{print()}.

   \subsection{How can I produce Black \& White lattice graphics?}

   What is the most elegant method to specify that strip panels should
   have transparent backgrounds and graphs should be rendered in black
   and white when using the lattice package with Sweave? A global
   option that persists across multiple plots is preferable.

   Answer by \I{Deepayan Sarkar}: Incorporate something like the
   following as part of the initialization:
\begin{verbatim}
 <<...>>=
 library(lattice)
 ltheme <- canonical.theme(color = FALSE)     ## in-built B&W theme
 ltheme$strip.background$col <- "transparent" ## change strip bg
 lattice.options(default.theme = ltheme)      ## set as default
 @
\end{verbatim}

  \subsection{Creating multiple figures from a single figure chunk
     does not work}

   Consider attempting to generate several graphs within a loop, such as:
\begin{verbatim}
 <<fig=TRUE>>=
 for (i in 1:4) plot(rnorm(100)+i)
 @
\end{verbatim}
   This will \textbf{not} succeed, because Sweave permits
   \textbf{only one graphic} per figure chunk. The reason is that
   Sweave opens a graphics device (e.g., \code{pdf}) before executing
   the chunk's code and closes it afterward. To plot multiple graphs
   within a loop, structure the code as follows:
\begin{verbatim}
 <<results=tex,echo=FALSE>>=
 for(i in 1:4){
    fname <- paste("myfile", i, ".pdf", sep = "")
    pdf(file = fname, width = 6, height = 6)
    plot(rnorm(100)+i)
    dev.off()
    cat("\\includegraphics{", fname, "}\n\n", sep = "")
 }
 @
\end{verbatim}


 \subsection{How can I set default \code{par()} settings for all
    figure chunks?}

  Because Sweave opens a new device for each figure chunk, a
  \code{par()} call only affects the chunk in which it appears. To
  apply consistent settings across a series of figures, using a hook
  function is more convenient than repeating the same \code{par()}
  statement in every chunk.

  The effect of:
\begin{verbatim}
  options(SweaveHooks = list(fig = function() par(bg = "red", fg = "blue")))
\end{verbatim}
  should be readily apparent.

  \subsection{How can I alter the formatting of R input and output
     chunks?}

   Sweave utilizes the \pkg{fancyvrb} package for formatting all \R{}
   code and text output. \pkg{fancyvrb} is a powerful and flexible
   package offering fine-grained control over the layout of verbatim
   text. To modify the default appearance, consult the \pkg{fancyvrb}
   documentation and adjust the definitions of the \code{Sinput} and
   \code{Soutput} environments in \file{Sweave.sty} accordingly.

  \subsection{How can I change the line length of R input and
     output?}

   Sweave respects the standard \R{} mechanism for specifying line
   length, namely \code{options(width)}. For example, after executing
   \code{options(width = 40)}, lines will be formatted to contain at
   most 40 characters (where possible).

   \subsection{Can I use Sweave to generate Microsoft Word documents?}

   Not directly. However, package~\CRANpkg{officer} provides
   functionality to manipulate Microsoft Word documents from within \R{}.

   \subsection{Can I use Sweave for \I{OpenDocument} files?}

   Not directly. The archived package \CRANpkg{odfWeave} (archived in 2018)
   provided functions for using Sweave in conjunction with OpenOffice
   Writer instead of \LaTeX{}. Consult the
   \href{https://CRAN.R-project.org/view=ReproducibleResearch}{CRAN
     Task View: Reproducible Research} for an up-to-date list of related
   tools and packages.

   \subsection{Can I use Sweave for HTML files?}

   Yes, package \CRANpkg{R2HTML} supplies a driver for using Sweave
   with HTML instead of \LaTeX{}.

   \subsection{After loading package \pkg{R2HTML}, Sweave ceases to
     function correctly!}

   Package \CRANpkg{R2HTML} registers an Sweave driver for HTML files
   using the same file extensions as the default \code{noweb}
   syntax. After loading, its syntax definition appears earlier in the
   search list than the default syntax. Using
\begin{verbatim}
  options(SweaveSyntax = "SweaveSyntaxNoweb")
\end{verbatim}
or calling Sweave with:
\begin{verbatim}
  Sweave(..., syntax = "SweaveSyntaxNoweb")
\end{verbatim}
ensures the default syntax is used even after \CRANpkg{R2HTML} is
loaded.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: